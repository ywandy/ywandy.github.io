<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YeweiAndy ‘S Blog 技术分享，生活随想</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.ywandy.top/"/>
  <updated>2019-04-16T02:15:44.910Z</updated>
  <id>https://blog.ywandy.top/</id>
  
  <author>
    <name>yewei_andy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解决linux下nodejs中watch文件最大数异常</title>
    <link href="https://blog.ywandy.top/%E8%A7%A3%E5%86%B3linux%E4%B8%8Bnodejs%E4%B8%ADwatch%E6%96%87%E4%BB%B6%E6%9C%80%E5%A4%A7%E6%95%B0%E5%BC%82%E5%B8%B8.html"/>
    <id>https://blog.ywandy.top/解决linux下nodejs中watch文件最大数异常.html</id>
    <published>2019-04-16T02:15:16.000Z</published>
    <updated>2019-04-16T02:15:44.910Z</updated>
    
    <content type="html"><![CDATA[<h3 id="解决在linux下使用nodejs出现的ENOSPC-System-limit-for-number-of-file-watchers-reached-问题"><a href="#解决在linux下使用nodejs出现的ENOSPC-System-limit-for-number-of-file-watchers-reached-问题" class="headerlink" title="解决在linux下使用nodejs出现的ENOSPC: System limit for number of file watchers reached 问题"></a>解决在linux下使用nodejs出现的ENOSPC: System limit for number of file watchers reached 问题</h3><h3 id="错误："><a href="#错误：" class="headerlink" title="错误："></a>错误：</h3><p><strong>ENOSPC: System limit for number of file watchers reached</strong></p><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><p>linux系统中限制了用户可以watch文件变更的最大数，因此需要通过sysctl.conf进行更改数值</p><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p</span><br></pre></td></tr></table></figure><h3 id="如果是archlinux："><a href="#如果是archlinux：" class="headerlink" title="如果是archlinux："></a>如果是archlinux：</h3><p>在文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```bash</span><br><span class="line">fs.inotify.max_user_watches=524288</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;解决在linux下使用nodejs出现的ENOSPC-System-limit-for-number-of-file-watchers-reached-问题&quot;&gt;&lt;a href=&quot;#解决在linux下使用nodejs出现的ENOSPC-System-limit-fo
      
    
    </summary>
    
      <category term="技巧总结" scheme="https://blog.ywandy.top/categories/%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="linux" scheme="https://blog.ywandy.top/tags/linux/"/>
    
      <category term="nodejs" scheme="https://blog.ywandy.top/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>解决centos的ssh链接慢问题</title>
    <link href="https://blog.ywandy.top/%E8%A7%A3%E5%86%B3centos%E7%9A%84ssh%E9%93%BE%E6%8E%A5%E6%85%A2%E9%97%AE%E9%A2%98.html"/>
    <id>https://blog.ywandy.top/解决centos的ssh链接慢问题.html</id>
    <published>2019-04-16T02:07:39.000Z</published>
    <updated>2019-04-16T02:10:02.021Z</updated>
    
    <content type="html"><![CDATA[<h3 id="以下提供2种解决思路："><a href="#以下提供2种解决思路：" class="headerlink" title="以下提供2种解决思路："></a>以下提供2种解决思路：</h3><h4 id="一、关闭dns反向解析-能达到显著的加速效果"><a href="#一、关闭dns反向解析-能达到显著的加速效果" class="headerlink" title="一、关闭dns反向解析(能达到显著的加速效果):"></a>一、关闭dns反向解析(能达到显著的加速效果):</h4><p>在linux中，默认开启了ssh反向dns解析，这个会消耗大量时间，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vi /etc/ssh/sshd_config</span></span><br><span class="line">UseDNS=no</span><br></pre></td></tr></table></figure><h4 id="二、关闭server的gss认证"><a href="#二、关闭server的gss认证" class="headerlink" title="二、关闭server的gss认证:"></a>二、关闭server的gss认证:</h4><p>在authentication gssapi-with-mic有很大的可能出现问题，因此关闭GSS认证可以提高ssh连接速度。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vi /etc/ssh/sshd_config</span></span><br><span class="line">GSSAPIAuthentication no</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;以下提供2种解决思路：&quot;&gt;&lt;a href=&quot;#以下提供2种解决思路：&quot; class=&quot;headerlink&quot; title=&quot;以下提供2种解决思路：&quot;&gt;&lt;/a&gt;以下提供2种解决思路：&lt;/h3&gt;&lt;h4 id=&quot;一、关闭dns反向解析-能达到显著的加速效果&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="技巧总结" scheme="https://blog.ywandy.top/categories/%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="linux" scheme="https://blog.ywandy.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes部署-多虚拟机部署</title>
    <link href="https://blog.ywandy.top/kubernetes%E9%83%A8%E7%BD%B2-%E5%A4%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%83%A8%E7%BD%B2.html"/>
    <id>https://blog.ywandy.top/kubernetes部署-多虚拟机部署.html</id>
    <published>2019-04-16T01:31:01.000Z</published>
    <updated>2019-04-16T02:03:49.949Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">author: yewei_andy</span><br><span class="line">email: 896882701yw@gmail.com</span><br></pre></td></tr></table></figure><h3 id="部署k8s分布式"><a href="#部署k8s分布式" class="headerlink" title="部署k8s分布式"></a>部署k8s分布式</h3><h4 id="主机配置："><a href="#主机配置：" class="headerlink" title="主机配置："></a>主机配置：</h4><h5 id="虚拟机方案："><a href="#虚拟机方案：" class="headerlink" title="虚拟机方案："></a>虚拟机方案：</h5><ol><li>使用虚拟机部署3个一样的centos7或者ubuntu虚拟机</li><li>配置2张网卡<ul><li>一张用来主机和虚拟机通讯(host only 网卡),master和node节点通信也是使用这张网卡</li><li>一张用来nat和外网通信</li></ul></li></ol><h5 id="三台物理机方案："><a href="#三台物理机方案：" class="headerlink" title="三台物理机方案："></a>三台物理机方案：</h5><ol><li>三台内网的主机即可，centos7或者ubuntu</li></ol><h4 id="配置docker的代理-主要用来拉取镜像使用"><a href="#配置docker的代理-主要用来拉取镜像使用" class="headerlink" title="配置docker的代理(主要用来拉取镜像使用)"></a>配置docker的代理(主要用来拉取镜像使用)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF &gt;/etc/systemd/system/docker.service.d/http-proxy.conf</span><br><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">"HTTP_PROXY=http://192.168.56.1:1087/"</span></span><br><span class="line">Environment=<span class="string">"HTTPS_PROXY=http://192.168.56.1:1087/"</span></span><br><span class="line">Environment=<span class="string">"NO_PROXY=localhost,127.0.0.1,localaddress,.localdomain.com"</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><ul><li><p>测试配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker info | grep Proxy  <span class="comment"># 有输出说明配置成功</span></span><br><span class="line">docker pull gcr.io/google-containers/hello-world <span class="comment"># pull 成功代表代理器工作正常。</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="配置终端代理-如果有需要"><a href="#配置终端代理-如果有需要" class="headerlink" title="配置终端代理(如果有需要)"></a>配置终端代理(如果有需要)</h4><h5 id="全局终端http-https代理"><a href="#全局终端http-https代理" class="headerlink" title="全局终端http/https代理:"></a>全局终端http/https代理:</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt;&gt;/etc/environment</span><br><span class="line">http_proxy=<span class="string">"http://&#123;http代理地址&#125;:8118/"</span></span><br><span class="line">https_proxy=<span class="string">"http://&#123;http代理地址&#125;:8118/"</span></span><br><span class="line">no_proxy=<span class="string">"localhost, 127.0.0.1"</span></span><br><span class="line">EOF</span><br><span class="line"><span class="built_in">source</span> /etc/environment</span><br></pre></td></tr></table></figure><h5 id="仅限当前shell生效的代理-使用export"><a href="#仅限当前shell生效的代理-使用export" class="headerlink" title="仅限当前shell生效的代理(使用export):"></a>仅限当前shell生效的代理(使用export):</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">"http://&#123;http代理地址&#125;:8118/"</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">"http://&#123;http代理地址&#125;:8118/"</span></span><br><span class="line"><span class="built_in">export</span> no_proxy=<span class="string">"localhost, 127.0.0.1"</span></span><br></pre></td></tr></table></figure><h4 id="修改host-conf文件"><a href="#修改host-conf文件" class="headerlink" title="修改host.conf文件"></a>修改host.conf文件</h4><p>修改这个文件的目的在于使用主机名都能访问，不需要输入ip地址</p><ul><li>三台机都要设置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#192.168.56.101 yeweinode1</span></span><br><span class="line"><span class="comment"># /etc/hosts</span></span><br><span class="line">&#123;节点1的ip&#125; 节点1的主机名</span><br><span class="line">&#123;节点2的ip&#125; 节点1的主机名</span><br><span class="line">&#123;节点3的ip&#125; 节点1的主机名</span><br></pre></td></tr></table></figure><h4 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h4><p>由于k8s会大量修改防火墙的配置，因此在使用k8s的时候尽量关闭iptables或者防火墙</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line">systemctl stop ufw</span><br><span class="line">systemctl <span class="built_in">disable</span> ufw</span><br></pre></td></tr></table></figure><h4 id="关闭selinux"><a href="#关闭selinux" class="headerlink" title="关闭selinux"></a>关闭selinux</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 临时禁用</span></span><br><span class="line">setenforce 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 永久禁用 </span></span><br><span class="line">vim /etc/selinux/config    <span class="comment"># 或者修改/etc/sysconfig/selinux</span></span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure><h4 id="关闭swap"><a href="#关闭swap" class="headerlink" title="关闭swap"></a>关闭swap</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 临时关闭</span></span><br><span class="line">swapoff -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释掉以下字段</span></span><br><span class="line">/dev/mapper/cl-swap     swap                    swap    defaults        0 0</span><br></pre></td></tr></table></figure><h5 id="如果不想关闭swap的话，需要做以下操作："><a href="#如果不想关闭swap的话，需要做以下操作：" class="headerlink" title="如果不想关闭swap的话，需要做以下操作："></a>如果不想关闭swap的话，需要做以下操作：</h5><ol><li><p>kubeadm 启动时候需要加入参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--ignore-preflight-errors=swap</span><br></pre></td></tr></table></figure></li><li><p>修改<code>/etc/systemd/system/kubelet.service.d/10-kubeadm.conf</code></p></li><li><p>在这个文件加入以下代码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Environment=<span class="string">"KUBELET_EXTRA_ARGS=--fail-swap-on=false"</span></span><br></pre></td></tr></table></figure><p>使得最后看起来像这样:</p><p><img src="http://storage.ywandy.top/20190416094438_KPueef_image-20190327143612345.jpeg" alt></p></li></ol><h4 id="命令行程序安装-安装kubectl-kubeadm-kubelet三个组件-："><a href="#命令行程序安装-安装kubectl-kubeadm-kubelet三个组件-：" class="headerlink" title="命令行程序安装(安装kubectl kubeadm kubelet三个组件)："></a>命令行程序安装(安装kubectl kubeadm kubelet三个组件)：</h4><h5 id="使用centos"><a href="#使用centos" class="headerlink" title="使用centos:"></a>使用centos:</h5><ul><li>配置软件源</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li>安装<strong><em>kubelet kubeadm kubectl</em></strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y kubelet kubeadm kubectl</span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure><h5 id="使用ubuntu"><a href="#使用ubuntu" class="headerlink" title="使用ubuntu:"></a>使用ubuntu:</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y apt-transport-https</span><br><span class="line">curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - </span><br><span class="line">cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.list</span><br><span class="line">deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main</span><br><span class="line">EOF  </span><br><span class="line">apt-get update</span><br><span class="line">apt-get install -y kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure><h4 id="使用kubeadm启动k8s"><a href="#使用kubeadm启动k8s" class="headerlink" title="使用kubeadm启动k8s"></a>使用kubeadm启动k8s</h4><ul><li>在node1(master)中执行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --apiserver-advertise-address=&#123;这里填写node1的host-only网卡的地址&#125; --pod-network-cidr=10.244.0.0/16 --ignore-preflight-errors=swap</span><br><span class="line"><span class="comment">#--apiserver-advertise-address 这个参数是k8s集群中master对外能访问的地址</span></span><br><span class="line"><span class="comment">#--pod-network-cidr=10.244.0.0/16 这一节是配置pod的内网网段</span></span><br><span class="line"><span class="comment">#--ignore-preflight-errors=swap 如果是使用swap启动的话，需要加这个参数</span></span><br></pre></td></tr></table></figure><ol><li><code>--apiserver-advertise-address=192.168.56.101</code> 绑定 apiserver 到 master 节点的 Host-Only 适配器的地址，默认是绑到 NAT 的地址上，这样其他机器是永远也访问不到的。</li><li><code>--pod-network-cidr=10.244.0.0/16</code> 指定 pod 网络地址空间，我们使用 flannel 组件必须使用这个空间<ul><li>等待node1执行结束，会有以下的输出：</li></ul></li></ol><p><img src="http://storage.ywandy.top/20190416094328_xmFxCd_image-20190327114031824.jpeg" alt></p><h4 id="配置kubectl，使得能连上k8s的apiserver"><a href="#配置kubectl，使得能连上k8s的apiserver" class="headerlink" title="配置kubectl，使得能连上k8s的apiserver"></a>配置kubectl，使得能连上k8s的apiserver</h4><p>这时候需要使用kubectl接入kubernets的api，在我们刚刚的kubeadm init时候，程序已经为我们创建了kubectl的配置文件，这时候我们只需要export到环境变量即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.如果是root用户的话</span><br><span class="line"><span class="comment"># root user</span></span><br><span class="line"><span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">2.如果是非root用户的话</span><br><span class="line"><span class="comment"># non-root user</span></span><br><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">3.如果从其他机器操作的话</span><br><span class="line"><span class="comment"># 从本地主机操作，需要在本地安装 kubectl 客户端</span></span><br><span class="line">mkdir -p ~/.kube</span><br><span class="line">scp &lt;username&gt;@&#123;远端服务器&#125;:/home/&lt;username&gt;/.kube/config ~/.kube/config <span class="comment"># 从 master 复制配置文件到本地</span></span><br><span class="line"><span class="comment">#把远端服务器的admin.conf拷贝到本地</span></span><br></pre></td></tr></table></figure><p>以上的操作其实是把kubectl需要用到的配置文件配置到kubectl的配置当中</p><p>当完成了以上操作后，kuberctl已经能使用了</p><ul><li>在终端输入：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl cluster-info</span><br></pre></td></tr></table></figure><ul><li>会有类似下面的输出：</li></ul><p><img src="http://storage.ywandy.top/20190416094438_huN7sN_image-20190327144224237.jpeg" alt></p><p>这时候kubectl命令是已经能正常连上api server，集群也处于可用状态</p><h4 id="安装flannel网络"><a href="#安装flannel网络" class="headerlink" title="安装flannel网络"></a>安装flannel网络</h4><ul><li>可以通过修改kube-flannel.yml文件去修改flannel的默认监听端口</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"></span><br><span class="line">给 /opt/bin/flanneld 命令添加 --iface=<span class="string">"br0"</span> 参数 </span><br><span class="line"><span class="comment">#按照实际情况进行配置（一般情况下不需要）</span></span><br><span class="line"></span><br><span class="line">kubectl apply -f kube-flannel.yml</span><br></pre></td></tr></table></figure><ul><li>测试配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods --all-namespaces -o wide </span><br><span class="line"><span class="comment"># 稍等一会，下载镜像需要一定时间，</span></span><br><span class="line"><span class="comment">#最后应该显示 flannel pods 是 Running 状态， kube-dns 也是 Running 状态</span></span><br></pre></td></tr></table></figure><p>​    如图：</p><p><img src="http://storage.ywandy.top/20190416095718_E7xJaU_image-20190416095647483.jpeg" alt></p><h4 id="让master节点也参与调度"><a href="#让master节点也参与调度" class="headerlink" title="让master节点也参与调度"></a>让master节点也参与调度</h4><p>如果需要在master也进行pod调度（k8s默认不进行pod调度) 执行以下指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># taint命令用于配置污点</span></span><br><span class="line"><span class="comment">#k8s通过设定是否能容忍污点</span></span><br><span class="line">kubectl taint nodes --all node-role.kubernetes.io/master-</span><br></pre></td></tr></table></figure><h4 id="其他节点加入集群"><a href="#其他节点加入集群" class="headerlink" title="其他节点加入集群"></a>其他节点加入集群</h4><ul><li>此时需要在要加入集群的服务器上面执行以下指令（当然网段要能访问到,并且已经安装了kubeadm）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join xxxxxxxxx:6443 --token xxxxxx.xxxxxxxx --discovery-token-ca-cert-hash sha256:xxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure><p>这时候会出现以下的信息，说明已经成功加入了集群</p><p><img src="http://storage.ywandy.top/20190416094438_lG3lu2_image-20190327114341988.jpeg" alt></p><h3 id="安装和配置kubernetes-dashboard"><a href="#安装和配置kubernetes-dashboard" class="headerlink" title="安装和配置kubernetes-dashboard"></a>安装和配置kubernetes-dashboard</h3><h4 id="安装kubernetes-dashboard"><a href="#安装kubernetes-dashboard" class="headerlink" title="安装kubernetes-dashboard"></a>安装kubernetes-dashboard</h4><ul><li><p>下载官方kubernetes-dashboard的k8s资源文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L http://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml -O</span><br></pre></td></tr></table></figure></li><li><p>把资源文件应用到k8s集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure></li><li><p>等待dashboard 完全启动，使用以下命令确认</p></li></ul><p><img src="http://storage.ywandy.top/20190416094438_M3oysh_image-20190327160432156.jpeg" alt></p><ul><li>此时，kubernetes-dashboard已经部署</li></ul><h4 id="配置kubernetes-dashboard的rbac策略"><a href="#配置kubernetes-dashboard的rbac策略" class="headerlink" title="配置kubernetes-dashboard的rbac策略"></a>配置kubernetes-dashboard的rbac策略</h4><p>kubernetes-dashboard比较坑的地方在于</p><ul><li><p>如果没有配置策略，那么在启动kubernetes-dashboard的时候会出现很多的warning，然后即使能登陆到kubernetes-dashboard，也无法访问里面的资源</p></li><li><p>配置rbac策略</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#admin-user-admin.rbac.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">admin-user</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># Create ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">admin-user</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"><span class="attr">  apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">  kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="attr">- kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">admin-user</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure></li><li><p>应用rbac策略到k8s集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f admin-user-admin.rbac.yaml</span><br></pre></td></tr></table></figure></li></ul><h4 id="得到用于登陆dashboard的secret"><a href="#得到用于登陆dashboard的secret" class="headerlink" title="得到用于登陆dashboard的secret"></a>得到用于登陆dashboard的secret</h4><ul><li>运行命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user|awk <span class="string">'&#123;print $1&#125;'</span>)</span><br></pre></td></tr></table></figure><ul><li>会得到以下的token</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Name:         admin-user-token-hmctl</span><br><span class="line">Namespace:    kube-system</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  kubernetes.io/service-account.name: admin-user</span><br><span class="line">              kubernetes.io/service-account.uid: 00774986-5066-11e9-a0e8-fe242749c541</span><br><span class="line"></span><br><span class="line">Type:  kubernetes.io/service-account-token</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">ca.crt:     1025 bytes</span><br><span class="line">namespace:  11 bytes</span><br><span class="line">token:      xxxxxxxxxxxxx</span><br></pre></td></tr></table></figure><h4 id="使用kubectl-proxy在本地打开dashboard"><a href="#使用kubectl-proxy在本地打开dashboard" class="headerlink" title="使用kubectl proxy在本地打开dashboard"></a>使用kubectl proxy在本地打开dashboard</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl proxy</span><br></pre></td></tr></table></figure><ul><li>访问dashboard</li></ul><p>本地浏览器地址栏输入:</p><p><code>localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/</code></p><p>会出现如下的页面:</p><p><img src="http://storage.ywandy.top/20190416094438_NhTgGj_image-20190327164400572.jpeg" alt></p><ul><li><p>输入刚刚拿到的令牌</p><p>如果没有配置rbac策略，在这个时候，使用令牌即使以admin-user登陆进去，也不能访问里面的资源</p></li><li><p>然后进入dashboard界面，如下:</p></li></ul><p><img src="http://storage.ywandy.top/20190416094438_uUnp0s_image-20190327165331282.jpeg" alt></p><p>此时，已经可以正常访问了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;
      
    
    </summary>
    
      <category term="容器技术" scheme="https://blog.ywandy.top/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
      <category term="环境安装" scheme="https://blog.ywandy.top/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    
    
      <category term="linux" scheme="https://blog.ywandy.top/tags/linux/"/>
    
      <category term="环境搭建" scheme="https://blog.ywandy.top/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
      <category term="docker" scheme="https://blog.ywandy.top/tags/docker/"/>
    
      <category term="kubernetes" scheme="https://blog.ywandy.top/tags/kubernetes/"/>
    
      <category term="容器" scheme="https://blog.ywandy.top/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu18.04安装cuda10和cudnn7.5</title>
    <link href="https://blog.ywandy.top/ubuntu18-04%E5%AE%89%E8%A3%85cuda10%E5%92%8Ccudnn7-5.html"/>
    <id>https://blog.ywandy.top/ubuntu18-04安装cuda10和cudnn7-5.html</id>
    <published>2019-04-12T08:18:24.000Z</published>
    <updated>2019-04-12T08:21:07.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ubuntu18-04部署cuda-10和cudnn-7-5"><a href="#ubuntu18-04部署cuda-10和cudnn-7-5" class="headerlink" title="ubuntu18.04部署cuda 10和cudnn 7.5"></a>ubuntu18.04部署cuda 10和cudnn 7.5</h2><h3 id="cuda安装："><a href="#cuda安装：" class="headerlink" title="cuda安装："></a>cuda安装：</h3><ul><li>先按照正确方法安装上显卡驱动（cuda版本和显卡驱动要在官网进行确定）</li><li>去这个网站下载cuda <a href="https://developer.nvidia.com/cuda-toolkit-archive" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-toolkit-archive</a></li><li>选择linux-&gt;x86_64-&gt;Ubuntu-&gt;18.04-&gt;run file(local) 进行下载</li><li>在服务器执行这个程序,按照提示安装，注意不要安装显卡驱动就好了</li></ul><h3 id="cudnn安装："><a href="#cudnn安装：" class="headerlink" title="cudnn安装："></a>cudnn安装：</h3><ul><li><p>注册nvidia的开发者账号</p></li><li><p>在这个页面 <a href="https://developer.nvidia.com/rdp/cudnn-download" target="_blank" rel="noopener">https://developer.nvidia.com/rdp/cudnn-download</a> 下载cudnn7.6</p></li><li><p>此时会下载一个tgz压缩包</p></li><li><p>在服务器中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf cudnn-10.0-linux-x64-v7.5.0.56.tgz</span><br><span class="line">cp cuda/* /usr/<span class="built_in">local</span>/cuda-10.0 -r</span><br></pre></td></tr></table></figure></li><li><p>复制过去后，已经完成cudnn库的安装</p></li></ul><h3 id="环境变量的设定"><a href="#环境变量的设定" class="headerlink" title="环境变量的设定"></a>环境变量的设定</h3><ul><li><p>在 <code>/etc/profile</code> 以及自己的<code>bashrc</code>中(~/.bashrc或者~/.zshrc)加入以下信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/cuda/lib64:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/usr/<span class="built_in">local</span>/lib</span><br><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/cuda/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_PRELOAD=/lib/x86_64-linux-gnu/librt.so.1</span><br></pre></td></tr></table></figure></li><li><p>重启服务器</p></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yewei @ DI-ROG in ~ [16:15:21]</span></span><br><span class="line">$ python3</span><br><span class="line">Python <span class="number">3.6</span><span class="number">.7</span> (default, Oct <span class="number">22</span> <span class="number">2018</span>, <span class="number">11</span>:<span class="number">32</span>:<span class="number">17</span>)</span><br><span class="line">[GCC <span class="number">8.2</span><span class="number">.0</span>] on linux</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tf.Session()</span><br><span class="line"><span class="number">2019</span><span class="number">-04</span><span class="number">-12</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">27.733171</span>: I tensorflow/core/platform/cpu_feature_guard.cc:<span class="number">141</span>] Your CPU supports instructions that this TensorFlow binary was <span class="keyword">not</span> compiled to use: AVX2 FMA</span><br><span class="line"><span class="number">2019</span><span class="number">-04</span><span class="number">-12</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">27.800581</span>: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:<span class="number">998</span>] successful NUMA node read <span class="keyword">from</span> SysFS had negative value (<span class="number">-1</span>), but there must be at least one NUMA node, so returning NUMA node zero</span><br><span class="line"><span class="number">2019</span><span class="number">-04</span><span class="number">-12</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">27.801337</span>: I tensorflow/compiler/xla/service/service.cc:<span class="number">150</span>] XLA service <span class="number">0x1ae2960</span> executing computations on platform CUDA. Devices:</span><br><span class="line"><span class="number">2019</span><span class="number">-04</span><span class="number">-12</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">27.801356</span>: I tensorflow/compiler/xla/service/service.cc:<span class="number">158</span>]   StreamExecutor device (<span class="number">0</span>): GeForce GTX <span class="number">1070</span>, Compute Capability <span class="number">6.1</span></span><br><span class="line"><span class="number">2019</span><span class="number">-04</span><span class="number">-12</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">27.821878</span>: I tensorflow/core/platform/profile_utils/cpu_utils.cc:<span class="number">94</span>] CPU Frequency: <span class="number">2808000000</span> Hz</span><br><span class="line"><span class="number">2019</span><span class="number">-04</span><span class="number">-12</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">27.822543</span>: I tensorflow/compiler/xla/service/service.cc:<span class="number">150</span>] XLA service <span class="number">0x21a6e90</span> executing computations on platform Host. Devices:</span><br><span class="line"><span class="number">2019</span><span class="number">-04</span><span class="number">-12</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">27.822565</span>: I tensorflow/compiler/xla/service/service.cc:<span class="number">158</span>]   StreamExecutor device (<span class="number">0</span>): &lt;undefined&gt;, &lt;undefined&gt;</span><br><span class="line"><span class="number">2019</span><span class="number">-04</span><span class="number">-12</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">27.822785</span>: I tensorflow/core/common_runtime/gpu/gpu_device.cc:<span class="number">1433</span>] Found device <span class="number">0</span> <span class="keyword">with</span> properties:</span><br><span class="line">name: GeForce GTX <span class="number">1070</span> major: <span class="number">6</span> minor: <span class="number">1</span> memoryClockRate(GHz): <span class="number">1.645</span></span><br><span class="line">pciBusID: <span class="number">0000</span>:<span class="number">01</span>:<span class="number">00.0</span></span><br><span class="line">totalMemory: <span class="number">7.93</span>GiB freeMemory: <span class="number">138.88</span>MiB</span><br><span class="line"><span class="number">2019</span><span class="number">-04</span><span class="number">-12</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">27.822800</span>: I tensorflow/core/common_runtime/gpu/gpu_device.cc:<span class="number">1512</span>] Adding visible gpu devices: <span class="number">0</span></span><br><span class="line"><span class="number">2019</span><span class="number">-04</span><span class="number">-12</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">27.823532</span>: I tensorflow/core/common_runtime/gpu/gpu_device.cc:<span class="number">984</span>] Device interconnect StreamExecutor <span class="keyword">with</span> strength <span class="number">1</span> edge matrix:</span><br><span class="line"><span class="number">2019</span><span class="number">-04</span><span class="number">-12</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">27.823543</span>: I tensorflow/core/common_runtime/gpu/gpu_device.cc:<span class="number">990</span>]      <span class="number">0</span></span><br><span class="line"><span class="number">2019</span><span class="number">-04</span><span class="number">-12</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">27.823547</span>: I tensorflow/core/common_runtime/gpu/gpu_device.cc:<span class="number">1003</span>] <span class="number">0</span>:   N</span><br><span class="line">2019-04-12 16:15:27.823678: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1115] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 138 MB memory) -&gt; physical GPU (device: 0, name: GeForce GTX 1070, pci bus id: 0000:01:00.0, compute capability: 6.1)</span><br><span class="line">&lt;tensorflow.python.client.session.Session object at <span class="number">0x7f94f9a04b00</span>&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>证明cuda和cudnn正常安装</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ubuntu18-04部署cuda-10和cudnn-7-5&quot;&gt;&lt;a href=&quot;#ubuntu18-04部署cuda-10和cudnn-7-5&quot; class=&quot;headerlink&quot; title=&quot;ubuntu18.04部署cuda 10和cudnn 7.5&quot;&gt;
      
    
    </summary>
    
      <category term="环境安装" scheme="https://blog.ywandy.top/categories/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    
    
      <category term="linux" scheme="https://blog.ywandy.top/tags/linux/"/>
    
      <category term="环境搭建" scheme="https://blog.ywandy.top/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>docker日志清理方法</title>
    <link href="https://blog.ywandy.top/docker%E6%97%A5%E5%BF%97%E6%B8%85%E7%90%86%E6%96%B9%E6%B3%95.html"/>
    <id>https://blog.ywandy.top/docker日志清理方法.html</id>
    <published>2019-04-03T08:31:55.000Z</published>
    <updated>2019-04-04T02:44:21.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker-日志清理方法"><a href="#docker-日志清理方法" class="headerlink" title="docker 日志清理方法"></a>docker 日志清理方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">author : yewei_andy</span><br><span class="line">email : 896882701yw@gmail.com</span><br></pre></td></tr></table></figure><h4 id="方法1-使用脚本定期清理-手动删除docker-容器的log文件"><a href="#方法1-使用脚本定期清理-手动删除docker-容器的log文件" class="headerlink" title="方法1: 使用脚本定期清理(手动删除docker 容器的log文件)"></a>方法1: 使用脚本定期清理(手动删除docker 容器的log文件)</h4><ul><li>找出docker容器的日志大小：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"======== docker containers logs file size ========"</span>  </span><br><span class="line">logs=$(find /var/lib/docker/containers/ -name *-json.log)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">log</span> <span class="keyword">in</span> <span class="variable">$logs</span>  </span><br><span class="line">        <span class="keyword">do</span>  </span><br><span class="line">             ls -lh <span class="variable">$log</span>   </span><br><span class="line">        <span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li>删除docker容器日志：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"======== start clean docker containers logs ========"</span>  </span><br><span class="line"></span><br><span class="line">logs=$(find /var/lib/docker/containers/ -name *-json.log)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">log</span> <span class="keyword">in</span> <span class="variable">$logs</span>  </span><br><span class="line">        <span class="keyword">do</span>  </span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"clean logs : <span class="variable">$log</span>"</span>  </span><br><span class="line">                cat /dev/null &gt; <span class="variable">$log</span>  </span><br><span class="line">        <span class="keyword">done</span>  </span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"======== end clean docker containers logs ========"</span></span><br></pre></td></tr></table></figure><h4 id="方法2-通过设定docker容器的日志大小-达到容量会自动清理"><a href="#方法2-通过设定docker容器的日志大小-达到容量会自动清理" class="headerlink" title="方法2: 通过设定docker容器的日志大小(达到容量会自动清理)"></a>方法2: 通过设定docker容器的日志大小(达到容量会自动清理)</h4><ul><li>使用docker-compose 设定：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nginx:</span> </span><br><span class="line"><span class="attr">  image:</span> <span class="attr">nginx:1.12.1</span> </span><br><span class="line"><span class="attr">  restart:</span> <span class="string">always</span> </span><br><span class="line"><span class="attr">  logging:</span> </span><br><span class="line"><span class="attr">    driver:</span> <span class="string">“json-file”</span> </span><br><span class="line"><span class="attr">    options:</span> </span><br><span class="line"><span class="attr">      max-size:</span> <span class="string">“5g”</span></span><br></pre></td></tr></table></figure><ul><li>使用docker全局配置：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"log-driver"</span>:<span class="string">"json-file"</span>,</span><br><span class="line">  <span class="attr">"log-opts"</span>: &#123;<span class="attr">"max-size"</span>:<span class="string">"500m"</span>, <span class="attr">"max-file"</span>:<span class="string">"3"</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;docker-日志清理方法&quot;&gt;&lt;a href=&quot;#docker-日志清理方法&quot; class=&quot;headerlink&quot; title=&quot;docker 日志清理方法&quot;&gt;&lt;/a&gt;docker 日志清理方法&lt;/h2&gt;&lt;figure class=&quot;highlight bash
      
    
    </summary>
    
      <category term="容器技术" scheme="https://blog.ywandy.top/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="https://blog.ywandy.top/tags/linux/"/>
    
      <category term="docker" scheme="https://blog.ywandy.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker清除中间镜像的方法</title>
    <link href="https://blog.ywandy.top/docker%E6%B8%85%E9%99%A4%E4%B8%AD%E9%97%B4%E9%95%9C%E5%83%8F%E7%9A%84%E6%96%B9%E6%B3%95.html"/>
    <id>https://blog.ywandy.top/docker清除中间镜像的方法.html</id>
    <published>2019-04-03T08:29:22.000Z</published>
    <updated>2019-04-04T02:44:28.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker清除中间镜像的方法"><a href="#docker清除中间镜像的方法" class="headerlink" title="docker清除中间镜像的方法"></a>docker清除中间镜像的方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">author : yewei_andy</span><br><span class="line">email : 896882701yw@gmail.com</span><br></pre></td></tr></table></figure><p>我们知道，使用docker的时候，经常会构建出中间镜像，中间镜像如果没有被删除的话，会占用很多的空间资源</p><h4 id="删除中间镜像："><a href="#删除中间镜像：" class="headerlink" title="删除中间镜像："></a>删除中间镜像：</h4><ul><li><p>使用以下命令删除中间镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images | grep <span class="string">"^&lt;none&gt;"</span> | awk <span class="string">"&#123;print <span class="variable">$3</span>&#125;"</span>)</span><br></pre></td></tr></table></figure></li><li><p>可以先用以下命令查看是否有中间镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images | grep <span class="string">"^&lt;none&gt;"</span> | awk <span class="string">"&#123;print <span class="variable">$3</span>&#125;"</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;docker清除中间镜像的方法&quot;&gt;&lt;a href=&quot;#docker清除中间镜像的方法&quot; class=&quot;headerlink&quot; title=&quot;docker清除中间镜像的方法&quot;&gt;&lt;/a&gt;docker清除中间镜像的方法&lt;/h2&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="容器技术" scheme="https://blog.ywandy.top/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="https://blog.ywandy.top/tags/linux/"/>
    
      <category term="docker" scheme="https://blog.ywandy.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>解决hexo博客的Next主题busuanzi_count失效方法</title>
    <link href="https://blog.ywandy.top/%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2%E7%9A%84Next%E4%B8%BB%E9%A2%98busuanzi-count%E5%A4%B1%E6%95%88%E6%96%B9%E6%B3%95.html"/>
    <id>https://blog.ywandy.top/解决hexo博客的Next主题busuanzi-count失效方法.html</id>
    <published>2018-11-08T03:06:52.000Z</published>
    <updated>2018-11-08T03:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>2018-10后，无法使用卜算子的统计功能</strong></p><h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><p>进入卜算子的官网，发现有两行重要提示：</p><p><strong>”因七牛强制过期『dn-lbstatics.qbox.me』域名，与客服沟通无果，只能更换域名到『busuanzi.ibruce.info』！“</strong></p><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>替换卜算子在next主题插件里面的域名</p><p>hexo-theme-next主题中使用了dn-lbstatics.qbox.me域名的文件位置为：</p><p><strong>themes\next\layout_third-party\analytics\busuanzi-counter.swig</strong></p><p>修改 <strong>busuanzi-counter.swig</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#把以下代码</span></span><br><span class="line">&lt;script async src=<span class="string">"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#替换成</span></span><br><span class="line">&lt;script async src=<span class="string">"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>随后重新生成和部署博客，即可看到卜算子功能修复</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;2018-10后，无法使用卜算子的统计功能&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;原因：&quot;&gt;&lt;a href=&quot;#原因：&quot; class=&quot;headerlink&quot; title=&quot;原因：&quot;&gt;&lt;/a&gt;原因：&lt;/h4&gt;&lt;p&gt;进入卜算子的官网，发现有两行重要提示：&lt;
      
    
    </summary>
    
      <category term="随手写写" scheme="https://blog.ywandy.top/categories/%E9%9A%8F%E6%89%8B%E5%86%99%E5%86%99/"/>
    
    
      <category term="博客" scheme="https://blog.ywandy.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>区块链的共识算法</title>
    <link href="https://blog.ywandy.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95.html"/>
    <id>https://blog.ywandy.top/区块链的共识算法.html</id>
    <published>2018-08-22T00:54:39.000Z</published>
    <updated>2019-04-03T05:36:54.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="区块链分类："><a href="#区块链分类：" class="headerlink" title="区块链分类："></a>区块链分类：</h2><h3 id="公有链："><a href="#公有链：" class="headerlink" title="公有链："></a>公有链：</h3><p>公有链通常也称为非许可链（Permissionless Blockchain），任何人都可以参与区块链数据维护和读取，容易部署应用程序，完全去中心化不受任何机构控制。 </p><p>公有链是真正意义上的完全去中心化的区块链，它通过密码学保证交易不可篡改，同时也利用密码学验证以及经济上的激励，在互为陌生的网络环境中建立共识，从而形成去中心化的信用机制。在公有链中的共识机制一般是工作量证明（PoW）和权益证明（PoS） 。 </p><h3 id="联盟链："><a href="#联盟链：" class="headerlink" title="联盟链："></a>联盟链：</h3><p>联盟链是一种需要注册许可的区块链，这种区块链也称为许可链（Permissioned Blockchain）。联盟链仅限于联盟成员参与，联盟规模可以大到国与国之间，也可以是不同的机构企业之间。</p><p> 区块链上的读写权限、参与记账权限按联盟规则来制定。整个网络由成员机构共同维护，网络接入一般通过成员机构的网关节点接入，共识过程由预先选好的节点控制。因此联盟链一般不采用工作量证明的挖矿机制，而是多采用权益证明（PoS）或PBFT（Practical Byzantine Fault Tolerant）、RAFT等共识算法。 、</p><h3 id="私有链："><a href="#私有链：" class="headerlink" title="私有链："></a>私有链：</h3><p>指其写入权限由某个组织和机构控制的区块链，参与节点的资格会被严格限制。由于参与节点是有限和可控的，因此私有链往往可以有极快的交易速度、更好的隐私保护、更低的交易成本、不容易被恶意攻击，并且能做到身份认证等金融行业必需的要求。相比中心化数据库，私有链能够防止机构内单节点故意隐瞒或者篡改数据，即使发生错误，也能够迅速发现来源。因此许多大型金融机构在目前更加倾向于使用私有链技术。</p><p>私有链的价值主要是提供安全、可追溯、不可篡改、自动执行的运算平台，可以同时防范来自内部和外部对数据的安全攻击，这个在传统的系统是很难做到的。</p><h2 id="共识算法分类："><a href="#共识算法分类：" class="headerlink" title="共识算法分类："></a>共识算法分类：</h2><h4 id="一、工作量证明（PoW）："><a href="#一、工作量证明（PoW）：" class="headerlink" title="一、工作量证明（PoW）："></a>一、工作量证明（PoW）：</h4><h5 id="代表项目：比特币（BTC"><a href="#代表项目：比特币（BTC" class="headerlink" title="代表项目：比特币（BTC)"></a>代表项目：比特币（BTC)</h5><p>为了实现对交易打时间戳，Hash交易数据。比特币用了工作量证明方法。网络中的每个节点从事于解决一个适度困难的密码难题。难题的解决方法是：把区块中的所有数据做SHA256哈希运算，并且得到哈希值小于给定的目标值。区块中还包含一个Nonce值，通过递增Nonce来寻找正确的哈希值。这个密码谜题被设计成，每隔10Mins会找到一个谜题答案。一旦正确的哈希值被找到，节点就会向网络中广播这个哈希值。这个哈希值可以很容易的被网络中的其他节点验证，节点可以对收到区块后对区块中的数据进行SHA256运算哈希值。要修改一个区块需要重做这个区块以及这个区块之后所有区块的工作量证明 。</p><p>例如：</p><p>​    这个密码难题是给定一个字符串“hello world”对字符串进行SHA256计算，如果得到hash为0000开头，那么验证通过，那么节点需要对字符串进行SHA256计算</p><h4 id="二、DPOS算法："><a href="#二、DPOS算法：" class="headerlink" title="二、DPOS算法："></a>二、DPOS算法：</h4><h5 id="代表项目：EOS"><a href="#代表项目：EOS" class="headerlink" title="代表项目：EOS"></a>代表项目：EOS</h5><p>POW的缺陷：</p><ol><li>矿池导致算力越来越集中</li><li>电力耗费过大 </li></ol><p>受托人的节点服务器相当于比特币网络里的矿机，在完成本职工作的同时可以领取区块奖励和交易的手续费。</p><p>一个区块链项目的受托人个数由项目发起方决定，一般是101个受托人。任何一个持币用户都可以参与到投票和竞选受托人这两个过程中。用户可以随时投票、撤票，每个用户投票的权重和自己的持币量成正比。投票和撤票可以随时进行，在每一轮(round)选举结束后，得票率最高的101（一般为101，也可以是其他数字，具体由区块链项目方决定）个用户则成为该项目的受托人，负责打包区块、维持系统的运转并获得相应的奖励。</p><p>选举的根本目的，是通过每个人的投票选举出社区里对项目发展和运行最有利的101个用户。这101个用户的服务器节点既可以高效维护系统的运转，而他们也会贡献自己的能力促进区块链项目的发展</p><h4 id="三、消逝时间量证明POET："><a href="#三、消逝时间量证明POET：" class="headerlink" title="三、消逝时间量证明POET："></a>三、消逝时间量证明POET：</h4><h5 id="代表项目：Hyperledger-Sawtooth"><a href="#代表项目：Hyperledger-Sawtooth" class="headerlink" title="代表项目：Hyperledger Sawtooth"></a>代表项目：Hyperledger Sawtooth</h5><p>每个节点在发布块以前都要从encalve（使用安全的CPU指令）获取一个随机等待时间，等待时间最短的先发布块，encalve有两个函数，一个是CreateTimer和CheckTimer，第一个是产生一个定时器，另一个是校验定时器是否合法，如果合法将会生成一个凭证，凭证可以用来校验这个随机时间是否使用encalve产生以及是否经过了这个随机等待时间</p><h4 id="四、股权证明机制POS："><a href="#四、股权证明机制POS：" class="headerlink" title="四、股权证明机制POS："></a>四、股权证明机制POS：</h4><h5 id="代表项目：以太坊"><a href="#代表项目：以太坊" class="headerlink" title="代表项目：以太坊"></a>代表项目：以太坊</h5><p>POS的核心是使用币龄，假设每个币每天产生1币龄，或者当你挖出一个块能直接清空币龄，当365币龄被清空，就能获得0.05个币的利息（年利率5%），其余的基本和POW是类似，基于工作量去证明。</p><h5 id="设计初衷："><a href="#设计初衷：" class="headerlink" title="设计初衷："></a>设计初衷：</h5><ol><li>比特币区块产量4年减半，挖矿难度变大，使得矿工可能人数变少，POS采用利息，而且必须打开POS客户端才能获得利息，使得网络节点数量处于健壮状态</li><li>由于有部分货币是利息产生，也就是即使有51%货币也不一定能造成51%攻击</li><li>解决了比特币的通货紧缩问题</li></ol><h4 id="五、拜占庭容错PBFT："><a href="#五、拜占庭容错PBFT：" class="headerlink" title="五、拜占庭容错PBFT："></a>五、拜占庭容错PBFT：</h4><h5 id="代表项目：Hyperledger-Fabric"><a href="#代表项目：Hyperledger-Fabric" class="headerlink" title="代表项目：Hyperledger Fabric"></a>代表项目：Hyperledger Fabric</h5><p>PBFT算法要求至少要4个参与者，一个被选举为军长，3个师长。军长接到总司令命令：你们向前行军500公里。军长就会给3个师长发命令向前行军500公里。3个师长收到消息后会执行命令，并汇报结果。A师长说我在首都以东500公里，B师长说我在首都以东500公里，C师长说我在首都以东250公里。军长总结3个师长的汇报，发现首都以东500公里占多数（2票&gt;1票），所以就会忽略C师长的汇报结果，给总司令汇报说，好了，现在部队是在首都以东500公里了。这就是PBFT算法。</p><p><strong>PBFT算法的核心理论是n&gt;=3f+1</strong><br> n是系统中的总节点数，f是允许出现<strong>故障</strong>的节点数。换句话说，如果这个系统允许出现f个故障，那么这个系统必须包括n个节点，才能解决故障。</p><h5 id="五个概念："><a href="#五个概念：" class="headerlink" title="五个概念："></a>五个概念：</h5><ol><li><p>client：请求（request）自愿者，上例中指总司令。</p></li><li><p>replica：副本，所有参与提供服务的节点，上例指军长和师长</p></li><li><p>primary：承担起提供服务主要职责的节点，上例是军长</p></li><li><p>backup：其他副本，但相对于primary角色。上例指师长。</p></li><li><p>view：处于存在primary-bakup场景中的相对稳定的关系，叫视图。</p></li></ol><p> 如果primary出现故障，这种相对稳定的视图关系就会转变（transit）。比如军长叛逃（出现故障，对外表现为不可见），那么某个师长就会转变成为军长。系统也就从视图a转变为视图b（a,b均为整数）。</p><h5 id="四个阶段："><a href="#四个阶段：" class="headerlink" title="四个阶段："></a>四个阶段：</h5><ol><li><p>请求(request)：client请求阶段（有些说法不包括这个阶段）。总司令给军长下命令。</p></li><li><p>预准备(pre-prepare)：主节点向所有backup节点发送预准备消息，其中包括当前视图编号，client请求以及请求摘要，签名是否一致等。军长对各位师长说：现在是我的View（视图），我是军长，你们都是师长，所有人都得听我的。现在公布总司令的命令（先说说总司令是谁，命令摘要）。</p></li><li><p>准备(prepare)：包括主节点在内的所有副本节点在收到准备消息之后，对消息的签名是否正确，视图编号是否一致，以及消息序号是否满足水线限制这三个条件进行验证，如果验证通过则把这个准备消息写入消息日志中。backup节点核对签名信息，比如其他师长听到总司令的名字，说对，总司令就是这个人没错，然后核对总司令曾经任命这家伙当军长，好吧，那就听他的吧。</p></li><li><p>确认(commit)：</p><p>每个副本接受确认消息的条件是：</p><ol><li><p>签名正确</p></li><li><p>消息的视图编号与节点的当前视图编号一致</p></li><li><p>消息的序号n满足水线条件</p></li></ol></li></ol><p>   在h和H之间。一旦确认消息的接受条件满足了，则该副本节点将确认消息写入消息日志中。每个师长都经过上述核对，确认无误，就会接受命令进行执行。</p><h4 id="六、Hyperledger-Kafka-分布式队列-："><a href="#六、Hyperledger-Kafka-分布式队列-：" class="headerlink" title="六、Hyperledger Kafka(分布式队列)："></a>六、Hyperledger Kafka(分布式队列)：</h4><h5 id="设计思路："><a href="#设计思路：" class="headerlink" title="设计思路："></a>设计思路：</h5><p>kafka是一个分布式高可用消息队列，可以有序的管理消息并在多个冗余副本间保证数据一致性。kafka集群的状态由zookeeper管理，选举leader节点。</p><p>orderer服务从kafka集群里获取相应topic（kafka的分区，用于在队列里隔离出多个数据域）的数据，以保证交易数据有序，借助了kafka的分布式一致机制。如下图：</p><p><img src="http://storage.ywandy.top/yewei-photo/180822/HkBlLFcc9j.png?imageslim" alt="mark"></p><h5 id="kafka和orderer通讯流程："><a href="#kafka和orderer通讯流程：" class="headerlink" title="kafka和orderer通讯流程："></a>kafka和orderer通讯流程：</h5><ol><li><p>Peer（客户端）通过GRPC发起通信，与Orderer连接成功之后，便可以向Orderer发送消息</p></li><li><p>Orderer通过Recv接口接收Peer发送过来的消息，并将消息推送到Kafka</p></li><li><p>同时与Kafka相连接的Orderer通过Consumer实例消费Kafka上的消息，将消费的消息进行同一排序（Order）</p></li><li><p>排序完成后，当达到生成数据块（Block）的条件:</p><ol><li><p>下一数据块定时器到期，定时器通过向Orderer向Kafka发送定时器消息，再通过Kafka消费来达到定时效果(Batch Timeout)。</p></li><li><p>每消费一条真实数据，就触发判断是否达到生成一个新的数据块条件(Batch Size)，该条件由当前待生成数据块的数据总的大小以及记录数决定），并创建新的数据块（CreateNextBlock），创建成功则将数据块写入ledger（WriteBlock）。 </p></li></ol></li></ol><h4 id="七、-Hyperledger-Solo-单节点排序"><a href="#七、-Hyperledger-Solo-单节点排序" class="headerlink" title="七、 Hyperledger Solo(单节点排序):"></a>七、 Hyperledger Solo(单节点排序):</h4><p>order-solo模式作为单节点通信模式，所有从peer收到的消息都在本节点进行排序与生成数据块，详细流程见下图： </p><p><img src="http://storage.ywandy.top/yewei-photo/180822/KIJ5mlbBEl.jpg?imageslim" alt="mark"></p><h5 id="solo-order的通信流程："><a href="#solo-order的通信流程：" class="headerlink" title="solo-order的通信流程："></a>solo-order的通信流程：</h5><ol><li>Peer（客户端）通过GRPC发起通信</li><li>与Orderer连接成功之后，便可以向Orderer发送消息。</li><li>Orderer通过Recv接口接收Peer发送过来的消息，Orderer将接收到的消息生成数据块，并将数据块存入ledger</li><li>peer通过deliver接口从orderer中的ledger获取数据块。 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;区块链分类：&quot;&gt;&lt;a href=&quot;#区块链分类：&quot; class=&quot;headerlink&quot; title=&quot;区块链分类：&quot;&gt;&lt;/a&gt;区块链分类：&lt;/h2&gt;&lt;h3 id=&quot;公有链：&quot;&gt;&lt;a href=&quot;#公有链：&quot; class=&quot;headerlink&quot; title=&quot;公
      
    
    </summary>
    
      <category term="区块链" scheme="https://blog.ywandy.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="https://blog.ywandy.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="共识" scheme="https://blog.ywandy.top/tags/%E5%85%B1%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>一步一步入门Hyperledger-composer-学习Playground</title>
    <link href="https://blog.ywandy.top/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%85%A5%E9%97%A8Hyperledger-composer-%E5%AD%A6%E4%B9%A0Playground.html"/>
    <id>https://blog.ywandy.top/一步一步入门Hyperledger-composer-学习Playground.html</id>
    <published>2018-08-21T14:01:48.000Z</published>
    <updated>2019-04-03T05:37:20.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Playground-教程"><a href="#Playground-教程" class="headerlink" title="Playground 教程:"></a>Playground 教程:</h1><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>我们将使用定义的fabric网络，并且把使用Hyperledger Composer 基于我们的fabric网络构建一个业务网络（business network ），同时我们一步一步完成从创建资产、创建参与者、编写智能合约把一个用户的资产转让给另外一个用户。在这个教程，将会使用Hyperledger Composer里面的套件——composer-playground。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标:"></a>目标:</h2><ol><li>使用Fabric搭建一个简单的网络</li><li>启动composer-playground并使用web沙盒编写和调试代码</li><li>创建资产（Asset）</li><li>创建参与者（Participants）</li><li>编写智能合约代码（Logic）用于资产的归属权更改</li><li>测试完成后把.bna文件导出，部署到刚刚的Fabric真实网络</li><li>使用composer-playground去连接部署上去的业务网络</li></ol><h2 id="实践"><a href="#实践" class="headerlink" title="实践:"></a>实践:</h2><h3 id="一、使用Fabric搭建一个简单的网络："><a href="#一、使用Fabric搭建一个简单的网络：" class="headerlink" title="一、使用Fabric搭建一个简单的网络："></a>一、使用Fabric搭建一个简单的网络：</h3><ol><li><p>进入<strong>fabric</strong>网络一键脚本的<strong>repo</strong>，然后执行<strong>startFarbic.sh</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./startFabric.sh</span><br></pre></td></tr></table></figure><p>此时会刷新出类似一下的信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Creating network &quot;composer_default&quot; with the default driver</span><br><span class="line">Creating orderer.example.com ... done</span><br><span class="line">Creating ca.org1.example.com ... done</span><br><span class="line">Creating couchdb             ... done</span><br><span class="line">Creating mongodb             ... done</span><br><span class="line">Creating peer0.org1.example.com ... done</span><br><span class="line">sleeping for 15 seconds to wait for fabric to complete start up</span><br><span class="line">2018-08-21 22:31:08.469 CST [msp] GetLocalMSP -&gt; DEBU 001 Returning existing local MSP</span><br><span class="line">2018-08-21 22:31:08.469 CST [msp] GetDefaultSigningIdentity -&gt; DEBU 002 Obtaining default signing identity</span><br><span class="line">2018-08-21 22:31:08.471 CST [channelCmd] InitCmdFactory -&gt; INFO 003 Endorser and orderer connections initialized</span><br><span class="line">.........................................................</span><br><span class="line">2018-08-21 22:31:08.958 CST [channelCmd] executeJoin -&gt; INFO 006 Successfully submitted proposal to join channel</span><br><span class="line">2018-08-21 22:31:08.958 CST [main] main -&gt; INFO 007 Exiting.....</span><br></pre></td></tr></table></figure><p>只需要看到最后面出现了<strong>successfully</strong>即可</p></li><li><p>等待网络完全启动完成，执行<strong>createPeerAdminCard.sh:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./createPeerAdminCard.sh</span><br></pre></td></tr></table></figure><p>这步会把创建composer的<strong>PeerAdmin Card</strong>（具体用途将在以后章节详细讲解），只需知道，需要有这个<strong>card</strong>才能接下来完成<strong>composer</strong>业务网络部署到真实的fabric网络。这个脚本会自动完成这一系列操作，执行了这个脚本，将会有类似以下的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Development only script <span class="keyword">for</span> Hyperledger Fabric control</span><br><span class="line">Running <span class="string">'createPeerAdminCard.sh'</span></span><br><span class="line">FABRIC_VERSION is <span class="built_in">unset</span>, assuming hlfv11</span><br><span class="line">FABRIC_START_TIMEOUT is <span class="built_in">unset</span>, assuming 15 (seconds)</span><br><span class="line"></span><br><span class="line">Using composer-cli at v0.19.12</span><br><span class="line"></span><br><span class="line">Successfully created business network card file to</span><br><span class="line">        Output file: /tmp/PeerAdmin@hlfv1.card</span><br><span class="line"></span><br><span class="line">Command succeeded</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Successfully imported business network card</span><br><span class="line">        Card file: /tmp/PeerAdmin@hlfv1.card</span><br><span class="line">        Card name: PeerAdmin@hlfv1</span><br><span class="line"></span><br><span class="line">Command succeeded</span><br><span class="line"></span><br><span class="line">The following Business Network Cards are available:</span><br><span class="line"></span><br><span class="line">Connection Profile: hlfv1</span><br><span class="line">┌─────────────────┬───────────┬──────────────────┐</span><br><span class="line">│ Card Name       │ UserId    │ Business Network │</span><br><span class="line">├─────────────────┼───────────┼──────────────────┤</span><br><span class="line">│ PeerAdmin@hlfv1 │ PeerAdmin │                  │</span><br><span class="line">└─────────────────┴───────────┴──────────────────┘</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Issue composer card list --card &lt;Card Name&gt; to get details a specific card</span><br><span class="line"></span><br><span class="line">Command succeeded</span><br></pre></td></tr></table></figure><p>我们可以使用 <code>composer card list</code> 去验证一下，同时使用<code>composer card list --card PeerAdmin@hlfv1</code> 可以返回具体的card信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  fabric-dev-servers git:(master) ✗ composer card list --card PeerAdmin@hlfv1</span><br><span class="line">userName:            PeerAdmin</span><br><span class="line">description:</span><br><span class="line">businessNetworkName:</span><br><span class="line">identityId:          114aab0e76bf0c78308f89efc4b8c9423e31568da0c340ca187a9b17aa9a4457</span><br><span class="line">roles:</span><br><span class="line">  - PeerAdmin</span><br><span class="line">  - ChannelAdmin</span><br><span class="line">connectionProfile:</span><br><span class="line">  name:   hlfv1</span><br><span class="line">  x-type: hlfv1</span><br><span class="line">credentials:         Credentials <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">Command succeeded</span><br></pre></td></tr></table></figure></li></ol><h3 id="二、启动composer-playground："><a href="#二、启动composer-playground：" class="headerlink" title="二、启动composer-playground："></a>二、启动composer-playground：</h3><p>只需要在命令行输入composer-playground:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer-playground</span><br></pre></td></tr></table></figure><p>会有以下的输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  fabric-dev-servers git:(master) ✗ composer-playground</span><br><span class="line">info: [Hyperledger-Composer] :LoadModule               :loadModule()              Loading composer-wallet-filesystem from /home/wwb/xinou-network/node_modules/composer-wallet-filesystem</span><br><span class="line">info: [Hyperledger-Composer] :PlaygroundAPI            :createServer()            Playground API started on port 8080</span><br></pre></td></tr></table></figure><p>说明<figure class="highlight plain"><figcaption><span>正确启动，并且监听**8080**端口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后访问浏览器的http://localhost:8080 即可访问composer-playground的web页面</span><br><span class="line"></span><br><span class="line">![composer-playground-overview](http://storage.ywandy.top/yewei-photo/180821/lm1GgaFf4G.png)</span><br><span class="line"></span><br><span class="line">### 三、启动web沙盒环境并调试代码：</span><br><span class="line"></span><br><span class="line">1. 点击进入如图所示区域，就是web沙盒的区域：</span><br><span class="line"></span><br><span class="line">   ![mark](http://storage.ywandy.top/yewei-photo/180821/5B03hl3aeI.png)</span><br><span class="line"></span><br><span class="line">2. 按照以下填写我们的**tutorial-network**，并且点击**depoly**</span><br><span class="line"></span><br><span class="line">   1. 这一步将会启动一个空的业务网络</span><br><span class="line"></span><br><span class="line">   2. 这个业务网络的名字叫做**turtorial-network**</span><br><span class="line"></span><br><span class="line">   3. 这个业务被**depoly**，默认的业务网卡（暂时有且只有一个）的是**admin@turtorial-network**</span><br><span class="line"></span><br><span class="line">      (业务网卡这边以后会有专门的章节讲解)</span><br><span class="line"></span><br><span class="line">   ![mark](http://storage.ywandy.top/yewei-photo/180821/AeBbdAamfi.png)</span><br><span class="line"></span><br><span class="line">3. 此时等depoly完成后，点击connect即可进入在线的沙盒环境：</span><br><span class="line"></span><br><span class="line">   ![mark](http://storage.ywandy.top/yewei-photo/180821/BdeCbB5kA5.png)</span><br><span class="line"></span><br><span class="line">   ![mark](http://storage.ywandy.top/yewei-photo/180821/1C9K5hAl2j.png)</span><br><span class="line"></span><br><span class="line">### 三、创建资产和参与者：</span><br><span class="line"></span><br><span class="line">#### 文件目录：</span><br><span class="line"></span><br><span class="line">  - 模型文件 (.cto)</span><br><span class="line"></span><br><span class="line">    （定义 Assets, Participants 和Transactions）</span><br><span class="line"></span><br><span class="line">- 智能合约(.js)</span><br><span class="line"></span><br><span class="line">  （使用JavaScript定义执行Transaction）</span><br><span class="line"></span><br><span class="line">- Query查询文件(.qry)</span><br><span class="line"></span><br><span class="line">  (定义couchdb的queries查询语句)</span><br><span class="line"></span><br><span class="line">- 访问权限控制文件(permissions.acl)</span><br><span class="line"></span><br><span class="line">  (定义权限访问控制的文件)</span><br><span class="line"></span><br><span class="line">#### 编写模型文件代码：</span><br><span class="line"></span><br><span class="line">1. 在`model.cto`文件里面输入以下代码:</span><br><span class="line"></span><br><span class="line">   ```js</span><br><span class="line">   namespace org.example.mynetwork //定义网络名</span><br><span class="line">   asset Commodity identified by tradingSymbol &#123; //定义一个资产</span><br><span class="line">       o String tradingSymbol</span><br><span class="line">       o String description</span><br><span class="line">       o String mainExchange</span><br><span class="line">       o Double quantity</span><br><span class="line">       --&gt; Trader owner</span><br><span class="line">   &#125;</span><br><span class="line">   participant Trader identified by tradeId &#123; //定义一个参与者</span><br><span class="line">       o String tradeId</span><br><span class="line">       o String firstName</span><br><span class="line">       o String lastName</span><br><span class="line">   &#125;</span><br><span class="line">   transaction Trade &#123; //定义一个transaction的数据结构</span><br><span class="line">       --&gt; Commodity commodity</span><br><span class="line">       --&gt; Trader newOwner</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h4 id="编写一个智能合约代码："><a href="#编写一个智能合约代码：" class="headerlink" title="编写一个智能合约代码："></a>编写一个智能合约代码：</h4><p>我们需要一个交易资产的智能合约，需要使用js实现这个。目前我们的<strong>composer-playground</strong>并没有这个<code>script.js</code></p><ol><li>我们点击<code>add file</code>，然后选择<code>script file</code></li></ol><p><img src="http://storage.ywandy.top/yewei-photo/180821/CcjFH8i7gi.png" alt="mark"></p><ol start="2"><li>随后我们会进入<code>script.js</code>，这时候可以把代码编写进那个在线的IDE</li></ol><p><img src="http://storage.ywandy.top/yewei-photo/180821/L064GAJ0mc.png" alt="mark"></p><ol start="3"><li>把以下代码复制进入<code>script.js</code>：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Track the trade of a commodity from one trader to another</span></span><br><span class="line"><span class="comment"> * @param &#123;org.example.mynetwork.Trade&#125; trade - the trade to be processed</span></span><br><span class="line"><span class="comment"> * @transaction</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">tradeCommodity</span>(<span class="params">trade</span>) </span>&#123;</span><br><span class="line">    trade.commodity.owner = trade.newOwner; <span class="comment">//通过把原本资产的owner设置成传参的新的owner</span></span><br><span class="line">    <span class="keyword">let</span> assetRegistry = <span class="keyword">await</span> getAssetRegistry(<span class="string">'org.example.mynetwork.Commodity'</span>); <span class="comment">//获取资产的对象</span></span><br><span class="line">    <span class="keyword">await</span> assetRegistry.update(trade.commodity); <span class="comment">//资产更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、部署网络并且测试"><a href="#四、部署网络并且测试" class="headerlink" title="四、部署网络并且测试:"></a>四、部署网络并且测试:</h3><h4 id="沙盒部署："><a href="#沙盒部署：" class="headerlink" title="沙盒部署："></a>沙盒部署：</h4><ol><li><p>点击右下角的<strong>Depoly changes</strong></p></li><li><p>这时候会提示部署成功，然后点击正上方的标签栏<strong>Test</strong> 进入测试的页面，如图：</p><p><img src="http://storage.ywandy.top/yewei-photo/180821/G19fma6a5L.png" alt="mark"></p></li></ol><h4 id="沙盒调试："><a href="#沙盒调试：" class="headerlink" title="沙盒调试："></a>沙盒调试：</h4><ol><li><p>选中Trader，然后点击右上角的 Create new participant，然后会弹出界面，输入以下的代码:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"$class"</span>: <span class="string">"org.example.mynetwork.Trader"</span>,</span><br><span class="line">  <span class="attr">"tradeId"</span>: <span class="string">"TRADER1"</span>,</span><br><span class="line">  <span class="attr">"firstName"</span>: <span class="string">"Jenny"</span>,</span><br><span class="line">  <span class="attr">"lastName"</span>: <span class="string">"Jones"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击确认后，再次重复刚刚步骤，并输入以下的代码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"<span class="variable">$class</span>"</span>: <span class="string">"org.example.mynetwork.Trader"</span>,</span><br><span class="line">  <span class="string">"tradeId"</span>: <span class="string">"TRADER2"</span>,</span><br><span class="line">  <span class="string">"firstName"</span>: <span class="string">"Amy"</span>,</span><br><span class="line">  <span class="string">"lastName"</span>: <span class="string">"Williams"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码作用是创建两个交易者，一个是Jenny Jones，他的tradeid是TRADER1，另一个是Williams Amy ，他的tradeid是TRADER2（在这个定义交易者的数据结构，是使用tradeID作为主键的，关于模型文件的讲解会在以后的章节讲解到）</p></li><li><p>选中Commdity然后点击右上角的Create new asset，并输入以下代码：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"$class"</span>: <span class="string">"org.example.mynetwork.Commodity"</span>,</span><br><span class="line">  <span class="attr">"tradingSymbol"</span>: <span class="string">"ABC"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"Test commodity"</span>,</span><br><span class="line">  <span class="attr">"mainExchange"</span>: <span class="string">"Euronext"</span>,</span><br><span class="line">  <span class="attr">"quantity"</span>: <span class="number">72.297</span>,</span><br><span class="line">  <span class="attr">"owner"</span>: <span class="string">"resource:org.example.mynetwork.Trader#TRADER1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候会创建一个叫做ABC的资产，属于TRADER1的，也就是Jenny Jones的</p></li><li><p>提交transaction，把物品ABC从TRADER1交易给TRADER2</p><p>点击Submit Transaction，然后确保Type选中Trade，然后输入以下代码:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"$class"</span>: <span class="string">"org.example.mynetwork.Trade"</span>,</span><br><span class="line">  <span class="attr">"commodity"</span>: <span class="string">"resource:org.example.mynetwork.Commodity#ABC"</span>,</span><br><span class="line">  <span class="attr">"newOwner"</span>: <span class="string">"resource:org.example.mynetwork.Trader#TRADER2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="http://storage.ywandy.top/yewei-photo/180821/DAl7bDg0LJ.png" alt="mark"></p><p>  当点击submit后，成功后会有以下提示:</p></li></ol><p><img src="http://storage.ywandy.top/yewei-photo/180821/igfh4DJIIc.png" alt="mark"></p><p> 说明交易已经成功了，我们看这条ABC的条目，发现owner已经变成TRADER2了，说明提交智能合约成功了，并且实现了智能合约更改物品的归属权。</p><h4 id="打包并且导出当前业务网络为-bna文件"><a href="#打包并且导出当前业务网络为-bna文件" class="headerlink" title="打包并且导出当前业务网络为.bna文件:"></a>打包并且导出当前业务网络为.bna文件:</h4><p>.bna文件可以用于使用composer命令行工具，实现业务网络的安装和更新，因此我们在沙盒测试完成后，需要导出这个.bna，才能用于后续的命令行部署到真实的fabric网络</p><ol><li>点击Define，回到原来编写代码的标签页</li><li>点击新增文件右边的export，即可获得当前业务网络的.bna文件</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Playground-教程&quot;&gt;&lt;a href=&quot;#Playground-教程&quot; class=&quot;headerlink&quot; title=&quot;Playground 教程:&quot;&gt;&lt;/a&gt;Playground 教程:&lt;/h1&gt;&lt;h2 id=&quot;介绍：&quot;&gt;&lt;a href=&quot;#介绍：&quot;
      
    
    </summary>
    
      <category term="区块链" scheme="https://blog.ywandy.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="https://blog.ywandy.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="hyperledger" scheme="https://blog.ywandy.top/tags/hyperledger/"/>
    
      <category term="composer" scheme="https://blog.ywandy.top/tags/composer/"/>
    
      <category term="nodejs" scheme="https://blog.ywandy.top/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>GO语言的变量</title>
    <link href="https://blog.ywandy.top/GO%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%98%E9%87%8F.html"/>
    <id>https://blog.ywandy.top/GO语言的变量.html</id>
    <published>2018-08-20T16:04:42.000Z</published>
    <updated>2018-08-20T16:25:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GO语言的变量"><a href="#GO语言的变量" class="headerlink" title="GO语言的变量"></a>GO语言的变量</h2><h3 id="（1）变量的声明"><a href="#（1）变量的声明" class="headerlink" title="（1）变量的声明:"></a>（1）变量的声明:</h3><h4 id="一、指定变量类型-如果不赋值，会有默认值"><a href="#一、指定变量类型-如果不赋值，会有默认值" class="headerlink" title="一、指定变量类型(如果不赋值，会有默认值):"></a>一、指定变量类型(如果不赋值，会有默认值):</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v_name v_type</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test1 <span class="keyword">string</span> <span class="comment">//没赋值，初始值为""空字符串</span></span><br><span class="line"><span class="keyword">var</span> test2 <span class="keyword">int</span> <span class="comment">//没赋值，初始值为0</span></span><br><span class="line"><span class="keyword">var</span> test3 <span class="keyword">string</span> = <span class="string">"test2"</span> <span class="comment">//赋值了，为"test2" String</span></span><br></pre></td></tr></table></figure><h4 id="二、根据值自行判定变量的类型："><a href="#二、根据值自行判定变量的类型：" class="headerlink" title="二、根据值自行判定变量的类型："></a>二、根据值自行判定变量的类型：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v_name = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test4 = <span class="string">"test4"</span> <span class="comment">//自动判断变量的类型,为"test4" String</span></span><br></pre></td></tr></table></figure><h4 id="三、省略var，使用-直接赋值-左侧变量不能为声明过的，且只能在函数体内使用-："><a href="#三、省略var，使用-直接赋值-左侧变量不能为声明过的，且只能在函数体内使用-：" class="headerlink" title="三、省略var，使用:=直接赋值(左侧变量不能为声明过的，且只能在函数体内使用)："></a>三、省略var，使用:=直接赋值(左侧变量不能为声明过的，且只能在函数体内使用)：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test5 := <span class="string">"test5"</span></span><br></pre></td></tr></table></figure><h4 id="实例程序"><a href="#实例程序" class="headerlink" title="实例程序:"></a>实例程序:</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test1 <span class="keyword">string</span> <span class="comment">//没赋值，初始值为""空字符串</span></span><br><span class="line"><span class="keyword">var</span> test2 <span class="keyword">int</span> <span class="comment">//没赋值，初始值为0</span></span><br><span class="line"><span class="keyword">var</span> test3 <span class="keyword">string</span> = <span class="string">"test2"</span> <span class="comment">//赋值了，为test2</span></span><br><span class="line"><span class="keyword">var</span> test4 = <span class="string">"test4"</span> <span class="comment">//自动判断变量的类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">test5 := <span class="string">"test5"</span></span><br><span class="line">fmt.Println(test1,test2,test3) <span class="comment">//打印第一种情况</span></span><br><span class="line">fmt.Println(test4)  <span class="comment">//打印第二种情况</span></span><br><span class="line">fmt.Println(test5) <span class="comment">//打印第三种情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到程序的输出:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> test2 <span class="comment">//打印第一种情况</span></span><br><span class="line">test4 <span class="comment">//打印第二种情况</span></span><br><span class="line">test5 <span class="comment">//打印第三种情况</span></span><br></pre></td></tr></table></figure><h3 id="（2）多变量的声明"><a href="#（2）多变量的声明" class="headerlink" title="（2）多变量的声明:"></a>（2）多变量的声明:</h3><h4 id="声明规则："><a href="#声明规则：" class="headerlink" title="声明规则："></a>声明规则：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型相同多个变量, 非全局变量</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span></span><br><span class="line">vname1, vname2, vname3 = v1, v2, v3</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 = v1, v2, v3 <span class="comment">//和python很像,不需要显示声明类型，自动推断</span></span><br><span class="line"></span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3 <span class="comment">//出现在:=左侧的变量不应该是已经被声明过的，否则会导致编译错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种因式分解关键字的写法一般用于声明全局变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    vname1 v_type1</span><br><span class="line">    vname2 v_type2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="实例代码："><a href="#实例代码：" class="headerlink" title="实例代码："></a>实例代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">a <span class="keyword">int</span></span><br><span class="line">b <span class="keyword">bool</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> c, d <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> e, f = <span class="number">123</span>, <span class="string">"hello world"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">g, h := <span class="number">456</span>, <span class="string">"hello go"</span></span><br><span class="line"><span class="built_in">println</span>(x,y,a,b,c,d,e,f,g,h)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到程序的输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="literal">false</span> <span class="number">1</span> <span class="number">2</span> <span class="number">123</span> hello world <span class="number">456</span> hello <span class="keyword">go</span></span><br></pre></td></tr></table></figure><h3 id="（3）值的类型和引用类型"><a href="#（3）值的类型和引用类型" class="headerlink" title="（3）值的类型和引用类型"></a>（3）值的类型和引用类型</h3><ol><li>所有像 <strong>int、float、bool 和 string</strong> 这些基本类型都属于<strong>值类型</strong>，使用这些类型的变量<strong>直接指向</strong>存在<strong>内存</strong>中的值： </li><li>当使用等号 <code>=</code> 将一个变量的值<strong>赋值</strong>给另一个变量时，如：<code>j = i</code>，实际上是在<strong>内存</strong>中将 i 的<strong>值</strong>进行了<strong>拷贝</strong>： </li><li><p>可以通过 <strong>&amp;i</strong> 来获取变量 i 的<strong>内存地址</strong>。值类型的变量的值存储在栈中。内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同。</p><ol><li><p>一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。 如图：</p></li><li><p>这个内存地址称为指针，实际上是存在另外的某一个字里面</p></li><li><p>同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在<strong>内存</strong>中，每个字都指示了下一个字所在的<strong>内存地址</strong>。 </p></li><li><p>当赋值语句<strong>r2 = r1</strong>，只是复制引用地址：</p><p>实例代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v1 <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> v2 <span class="keyword">int</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> v3, v4 = v1, v2 <span class="comment">//v3,v4为v1 v2的拷贝</span></span><br><span class="line"><span class="keyword">var</span> v5, v6 = &amp;v1, &amp;v2 <span class="comment">//v5,v6为v1 v2的引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">println</span>(v1,<span class="string">" "</span>,v2)<span class="comment">//打印原值v1 v2</span></span><br><span class="line"><span class="built_in">println</span>(v3,<span class="string">" "</span>,v4) <span class="comment">//打印拷贝的v1 v2</span></span><br><span class="line"><span class="built_in">println</span>(v5,<span class="string">" "</span>,v6) <span class="comment">//打印v1 v2的引用</span></span><br><span class="line"><span class="built_in">println</span>(*v5,<span class="string">" "</span>,*v6) <span class="comment">//打印v1 v2的解引用（引用的地址的值）</span></span><br><span class="line">v2 = <span class="number">3</span> <span class="comment">// 修改v2为3</span></span><br><span class="line"><span class="built_in">println</span>(*v5,<span class="string">" "</span>,*v6) <span class="comment">//打印v1 v2的解引用（引用的地址的值）</span></span><br><span class="line"><span class="built_in">println</span>(v3,<span class="string">" "</span>,v4) <span class="comment">//打印拷贝的v1 v2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1   2 //打印原值v1 v2</span><br><span class="line">1   2 //打印拷贝的v1 v2</span><br><span class="line">0x49d138   0x49d140 //打印v1 v2的引用</span><br><span class="line">1   2 //打印v1 v2的解引用（引用的地址的值）</span><br><span class="line">1   3 //打印v1 v2的解引用（引用的地址的值）(修改v2为3后) 发现变化了</span><br><span class="line">1   2 //打印拷贝的v1 v2，因为不是引用，因此不会变化</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GO语言的变量&quot;&gt;&lt;a href=&quot;#GO语言的变量&quot; class=&quot;headerlink&quot; title=&quot;GO语言的变量&quot;&gt;&lt;/a&gt;GO语言的变量&lt;/h2&gt;&lt;h3 id=&quot;（1）变量的声明&quot;&gt;&lt;a href=&quot;#（1）变量的声明&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="编程语言" scheme="https://blog.ywandy.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="GO" scheme="https://blog.ywandy.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/GO/"/>
    
    
      <category term="go" scheme="https://blog.ywandy.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Fabric在阿里云安装出现的一些问题解决</title>
    <link href="https://blog.ywandy.top/Fabric%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%89%E8%A3%85%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.html"/>
    <id>https://blog.ywandy.top/Fabric在阿里云安装出现的一些问题解决.html</id>
    <published>2018-08-19T14:55:37.000Z</published>
    <updated>2018-08-19T15:05:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hyperledger-Fabric在阿里云安装出现的一些问题解决"><a href="#Hyperledger-Fabric在阿里云安装出现的一些问题解决" class="headerlink" title="Hyperledger Fabric在阿里云安装出现的一些问题解决"></a>Hyperledger Fabric在阿里云安装出现的一些问题解决</h2><h3 id="1-signal-SIGSEGV-segmentation-violation-code-0x1-addr-xxx-pc-xxx-类似的错误"><a href="#1-signal-SIGSEGV-segmentation-violation-code-0x1-addr-xxx-pc-xxx-类似的错误" class="headerlink" title="1. [signal SIGSEGV: segmentation violation code=0x1 addr=xxx pc=xxx]  类似的错误:"></a>1. [signal SIGSEGV: segmentation violation code=0x1 addr=xxx pc=xxx]  类似的错误:</h3><h3 id="原始错误的代码-来自peer节点"><a href="#原始错误的代码-来自peer节点" class="headerlink" title="原始错误的代码(来自peer节点):"></a>原始错误的代码(来自peer节点):</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-19</span> <span class="number">22</span>:<span class="number">43</span>:<span class="number">43.665</span> CST [couchdb] handleRequest -&gt; WARN <span class="number">016</span> Retrying couchdb request in <span class="number">125</span>ms. Attempt:<span class="number">1</span>  Error:Get http:<span class="comment">//couchdb:5984/: dial tcp 172.18.0.4:5984: getsockopt: connection refused</span></span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-19</span> <span class="number">22</span>:<span class="number">43</span>:<span class="number">43.790</span> CST [couchdb] handleRequest -&gt; DEBU <span class="number">017</span> HTTP Request: GET / HTTP/<span class="number">1.1</span> | Host: couchdb:<span class="number">5984</span> | User-Agent: Go-http-client/<span class="number">1.1</span> | Accept: multipart/related | Accept-Encoding: gzip |  |</span><br><span class="line">fatal error: unexpected signal during runtime execution</span><br><span class="line">[signal SIGSEGV: segmentation violation code=<span class="number">0x1</span> addr=<span class="number">0x63</span> pc=<span class="number">0x7f</span>17e8243259]</span><br><span class="line"></span><br><span class="line">runtime stack:</span><br><span class="line">runtime.throw(<span class="number">0xf11259</span>, <span class="number">0x2a</span>)</span><br><span class="line">        /opt/<span class="keyword">go</span>/src/runtime/<span class="built_in">panic</span>.<span class="keyword">go</span>:<span class="number">605</span> +<span class="number">0x95</span></span><br><span class="line">runtime.sigpanic()</span><br><span class="line">        /opt/<span class="keyword">go</span>/src/runtime/signal_unix.<span class="keyword">go</span>:<span class="number">351</span> +<span class="number">0x2b8</span></span><br><span class="line"></span><br><span class="line">goroutine <span class="number">88</span> [syscall, locked to thread]:</span><br><span class="line">runtime.cgocall(<span class="number">0xbf</span>3800, <span class="number">0xc42028f</span>ac8, <span class="number">0xf0f</span>a21)</span><br></pre></td></tr></table></figure><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h3><p>修改自己阿里云ecs机器里面的<strong>/etc/resolv.conf</strong>，把里面的 <strong>options timeout:2 attempts:3 rotate single-request-reopen</strong> 这一行内容注释掉 :<br>例如我的<strong>/etc/resolv.conf</strong> :  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)</span></span><br><span class="line"><span class="comment">#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN</span></span><br><span class="line">nameserver 100.100.2.136</span><br><span class="line">nameserver 100.100.2.138</span><br><span class="line"><span class="comment">#options timeout:2 attempts:3 rotate single-request-reopen</span></span><br></pre></td></tr></table></figure><p>然后问题就解决了</p><h3 id="原因解析"><a href="#原因解析" class="headerlink" title="原因解析:"></a>原因解析:</h3><p>这个问题是出在go的<strong>DNS解析问题</strong>，由于go的<strong>Resolver</strong>不支持<code>options single-request-reopen</code>从而走了<code>CGO Resolver</code>方法导致失败了，因此只需要把<code>/etc/resolv.conf</code>里面的<code>single-request-reopen</code>这一行注释掉即可</p><p>参考为什么通过CGO Resolver失败的原因: <a href="https://tschottdorf.github.io/golang-static-linking-bug?spm=a2c4e.11153940.blogcont238940.16.4d5848daofTdmA" target="_blank" rel="noopener">Static Cgo Builds, What Could Go Wrong?</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Hyperledger-Fabric在阿里云安装出现的一些问题解决&quot;&gt;&lt;a href=&quot;#Hyperledger-Fabric在阿里云安装出现的一些问题解决&quot; class=&quot;headerlink&quot; title=&quot;Hyperledger Fabric在阿里云安装出现
      
    
    </summary>
    
      <category term="区块链" scheme="https://blog.ywandy.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="go" scheme="https://blog.ywandy.top/tags/go/"/>
    
      <category term="区块链" scheme="https://blog.ywandy.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="hyperledger" scheme="https://blog.ywandy.top/tags/hyperledger/"/>
    
      <category term="linux" scheme="https://blog.ywandy.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下GO环境安装</title>
    <link href="https://blog.ywandy.top/Linux%E4%B8%8BGO%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85.html"/>
    <id>https://blog.ywandy.top/Linux下GO环境安装.html</id>
    <published>2018-08-16T03:59:29.000Z</published>
    <updated>2018-08-20T16:12:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux-下GO-环境安装"><a href="#Linux-下GO-环境安装" class="headerlink" title="Linux 下GO 环境安装:"></a>Linux 下GO 环境安装:</h2><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境:"></a>安装环境:</h3><ol><li><p>从Golang DL下载go1.10.3.linux-amd64.tar.gz</p><figure class="highlight plain"><figcaption><span>https://dl.google.com/go/go1.10.3.linux-amd64.tar.gz```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 解压`go1.10.3.linux-amd64.tar.gz` </span><br><span class="line"></span><br><span class="line">   ```tar zxvf go1.10.3.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>移动go到/usr/local</p><figure class="highlight plain"><figcaption><span>go</span><a href="/usr/local```">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 在`~/.profile`加入环境变量:</span><br></pre></td></tr></table></figure><p>export PATH=$PATH:/usr/local/go/bin<br>export PATH=$PATH:$GOROOT/bin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. 在家目录下建立go目录:</span><br><span class="line"></span><br><span class="line">   `mkdir -p ~/go `  </span><br><span class="line"></span><br><span class="line">6. 创建一个工程路径（GOPATH)例如我在家目录创建work路径：</span><br><span class="line"></span><br><span class="line">   `mkdir ~/work -p`</span><br><span class="line"></span><br><span class="line">7. 加入`~/work`到.profile环境变量：</span><br><span class="line"></span><br><span class="line">   ```export GOPATH=~/work```  </span><br><span class="line"></span><br><span class="line">8. 使.profile生效:</span><br><span class="line"></span><br><span class="line">   `source ~/.profile`</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">### 测试环境:</span><br><span class="line"></span><br><span class="line">1. 在命令行打入`go version`可以看到类似:</span><br><span class="line"></span><br><span class="line">   ```bash</span><br><span class="line">   # yewei @ xinou-work in ~/yyw/fabric/work [9:58:07]</span><br><span class="line">   $ go version</span><br><span class="line">   go version go1.10.3 linux/amd64</span><br></pre></td></tr></table></figure></li><li><p>在命令行打入<code>go env</code>可以看到类似:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yewei @ xinou-work in ~/yyw/fabric/work [10:00:50]</span></span><br><span class="line">$ go env</span><br><span class="line">GOARCH=<span class="string">"amd64"</span></span><br><span class="line">GOBIN=<span class="string">""</span></span><br><span class="line">GOCACHE=<span class="string">"/home/yewei/.cache/go-build"</span></span><br><span class="line">GOEXE=<span class="string">""</span></span><br><span class="line">GOHOSTARCH=<span class="string">"amd64"</span></span><br><span class="line">GOHOSTOS=<span class="string">"linux"</span></span><br><span class="line">GOOS=<span class="string">"linux"</span></span><br><span class="line">GOPATH=<span class="string">"/home/yewei/yyw/fabric/work"</span></span><br><span class="line">GORACE=<span class="string">""</span></span><br><span class="line">GOROOT=<span class="string">"/home/yewei/go"</span></span><br><span class="line">GOTMPDIR=<span class="string">""</span></span><br><span class="line">GOTOOLDIR=<span class="string">"/home/yewei/go/pkg/tool/linux_amd64"</span></span><br><span class="line">GCCGO=<span class="string">"gccgo"</span></span><br><span class="line">CC=<span class="string">"gcc"</span></span><br><span class="line">CXX=<span class="string">"g++"</span></span><br><span class="line">CGO_ENABLED=<span class="string">"1"</span></span><br><span class="line">CGO_CFLAGS=<span class="string">"-g -O2"</span></span><br><span class="line">CGO_CPPFLAGS=<span class="string">""</span></span><br><span class="line">CGO_CXXFLAGS=<span class="string">"-g -O2"</span></span><br><span class="line">CGO_FFLAGS=<span class="string">"-g -O2"</span></span><br><span class="line">CGO_LDFLAGS=<span class="string">"-g -O2"</span></span><br><span class="line">PKG_CONFIG=<span class="string">"pkg-config"</span></span><br><span class="line">GOGCCFLAGS=<span class="string">"-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build424194477=/tmp/go-build -gno-record-gcc-switches"</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>~/work/</code>创建一个<code>src/hello</code>文件夹，并创建文件<code>hello.go</code>文件，并敲入以下代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    </span><br><span class="line">fmt.Printf(<span class="string">"hello, world\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在~/work/下面执行<code>go install hello</code>，此时会构建<code>src/hello</code>里面的源码，生成<code>bin</code>文件夹</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux-下GO-环境安装&quot;&gt;&lt;a href=&quot;#Linux-下GO-环境安装&quot; class=&quot;headerlink&quot; title=&quot;Linux 下GO 环境安装:&quot;&gt;&lt;/a&gt;Linux 下GO 环境安装:&lt;/h2&gt;&lt;h3 id=&quot;安装环境&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="环境安装" scheme="https://blog.ywandy.top/categories/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    
    
      <category term="go" scheme="https://blog.ywandy.top/tags/go/"/>
    
      <category term="linux" scheme="https://blog.ywandy.top/tags/linux/"/>
    
      <category term="环境搭建" scheme="https://blog.ywandy.top/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>fabric的编译安装</title>
    <link href="https://blog.ywandy.top/fabric%E7%9A%84%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85.html"/>
    <id>https://blog.ywandy.top/fabric的编译安装.html</id>
    <published>2018-08-16T03:57:18.000Z</published>
    <updated>2018-08-19T13:33:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装go"><a href="#安装go" class="headerlink" title="安装go"></a>安装go</h1><p>可以参照我上一篇博客<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.google.com/go/go1.10.3.linux-amd64.tar.gz</span><br><span class="line">tar -xvf go1.10.3.linux-amd64.tar.gz</span><br><span class="line">mv go /usr/<span class="built_in">local</span>/</span><br><span class="line">mkdir -p ~/go  </span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="built_in">export</span> GOPATH=~/work</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin:<span class="variable">$GOPATH</span>/bin</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></p><h1 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install -y libsnappy-dev zlib1g-dev libbz2-dev libltdl-dev libtool</span><br></pre></td></tr></table></figure><h1 id="Fabric源码下载"><a href="#Fabric源码下载" class="headerlink" title="Fabric源码下载"></a>Fabric源码下载</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hyperledger/fabric <span class="variable">$GOPATH</span>/src/github.com/hyperledger/fabric</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/hyperledger/fabric-ca <span class="variable">$GOPATH</span>/src/github.com/hyperledger/fabric-ca</span><br></pre></td></tr></table></figure><p>或<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/hyperledger/fabric</span><br><span class="line">go get github.com/hyperledger/fabric-ca</span><br></pre></td></tr></table></figure></p><h1 id="编译fabric代码"><a href="#编译fabric代码" class="headerlink" title="编译fabric代码"></a>编译fabric代码</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/hyperledger/fabric</span><br><span class="line">make native</span><br><span class="line">make docker</span><br><span class="line">cp build/bin/* <span class="variable">$GOPATH</span>/bin/</span><br></pre></td></tr></table></figure><h1 id="解决编译fabric过程中报错"><a href="#解决编译fabric过程中报错" class="headerlink" title="解决编译fabric过程中报错"></a>解决编译fabric过程中报错</h1><h4 id="1-解决make-docker时候报错golang-x-tool错误"><a href="#1-解决make-docker时候报错golang-x-tool错误" class="headerlink" title="1. 解决make docker时候报错golang-x-tool错误:"></a>1. 解决make docker时候报错golang-x-tool错误:</h4><p>错误信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package golang.org/x/tools/go/gcexportdata: unrecognized import path <span class="string">"golang.org/x/tools/go/gcexportdata"</span></span><br></pre></td></tr></table></figure><p>解决方案<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/golang/tools.git <span class="variable">$GOPATH</span>/src/golang.org/x/tool</span><br></pre></td></tr></table></figure></p><h4 id="2-解决：cp-cannot-stat-‘build-docker-gotools-bin-protoc-gen-go’-No-such-file-or-directory"><a href="#2-解决：cp-cannot-stat-‘build-docker-gotools-bin-protoc-gen-go’-No-such-file-or-directory" class="headerlink" title="2. 解决：cp: cannot stat ‘build/docker/gotools/bin/protoc-gen-go’: No such file or directory"></a>2. 解决：cp: cannot stat ‘build/docker/gotools/bin/protoc-gen-go’: No such file or directory</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/golang/protobuf/protoc-gen-go</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/golang/protobuf/</span><br><span class="line">make all</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/hyperledger/fabric</span><br><span class="line">cp <span class="variable">$GOPATH</span>/bin/protoc-gen-go .build/docker/gotools/bin/</span><br></pre></td></tr></table></figure><h1 id="编译fabric-ca代码"><a href="#编译fabric-ca代码" class="headerlink" title="编译fabric-ca代码"></a>编译fabric-ca代码</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/hyperledger/fabric-ca</span><br><span class="line">make docker</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/hyperledger/fabric</span><br><span class="line">make release</span><br><span class="line">make docker</span><br><span class="line">cp .build/bin/* <span class="variable">$GOPATH</span>/bin/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装go&quot;&gt;&lt;a href=&quot;#安装go&quot; class=&quot;headerlink&quot; title=&quot;安装go&quot;&gt;&lt;/a&gt;安装go&lt;/h1&gt;&lt;p&gt;可以参照我上一篇博客&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="环境安装" scheme="https://blog.ywandy.top/categories/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    
    
      <category term="go" scheme="https://blog.ywandy.top/tags/go/"/>
    
      <category term="区块链" scheme="https://blog.ywandy.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="hyperledger" scheme="https://blog.ywandy.top/tags/hyperledger/"/>
    
      <category term="fabric" scheme="https://blog.ywandy.top/tags/fabric/"/>
    
  </entry>
  
  <entry>
    <title>一步一步构建Hyperledger composer 开发环境(二)</title>
    <link href="https://blog.ywandy.top/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%9E%84%E5%BB%BAHyperledger-composer-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E4%BA%8C.html"/>
    <id>https://blog.ywandy.top/一步一步构建Hyperledger-composer-开发环境-二.html</id>
    <published>2018-08-15T06:53:43.000Z</published>
    <updated>2018-08-19T13:34:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Hyperledger-composer"><a href="#安装Hyperledger-composer" class="headerlink" title="安装Hyperledger composer"></a>安装Hyperledger composer</h2><h3 id="一、安装前准备"><a href="#一、安装前准备" class="headerlink" title="一、安装前准备:"></a>一、安装前准备:</h3><ul><li>操作系统: ubuntu 14.04/16.04 LTS  </li><li>Docker: 17.03或者更高 </li><li>Docker-Compose: 1.8或者更高 </li><li>Node: 8.9 或者更高(大于9.0版本不兼容)</li><li>npm: v5.x</li><li>git: 2.9.x 或者更高</li><li>代码编辑器，例如Visual Studio Code  </li></ul><h3 id="二、安装需要的组件"><a href="#二、安装需要的组件" class="headerlink" title="二、安装需要的组件:"></a>二、安装需要的组件:</h3><p>使用以下的命令从网上下载上述的依赖:  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://hyperledger.github.io/composer/latest/prereqs-ubuntu.sh</span><br><span class="line">chmod u+x prereqs-ubuntu.sh</span><br><span class="line">./prereqs-ubuntu.sh</span><br></pre></td></tr></table></figure><p>以上步骤完成后，就可以开始下面的步骤，安装开发环境.  </p><h3 id="三、安装开发环境"><a href="#三、安装开发环境" class="headerlink" title="三、安装开发环境:"></a>三、安装开发环境:</h3><h4 id="（1）安装Cli工具"><a href="#（1）安装Cli工具" class="headerlink" title="（1）安装Cli工具:"></a>（1）安装Cli工具:</h4><p><strong>Composer</strong>自带了很多的命令行工具。最重要的是<code>composer-cli</code>，它包含所有必要的操作，接下来安装的<code>generator-hyperledger-composer</code>，<code>composer-rest-server</code>以及<code>Yeoman</code>，在构建于业务网络交互的应用程序会很有用。  </p><ol><li><p>工具安装:  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g composer-cli@0.20</span><br></pre></td></tr></table></figure></li><li><p>REST Server 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g composer-rest-server@0.20</span><br></pre></td></tr></table></figure></li><li><p>生成器的安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g generator-hyperledger-composer@0.20</span><br></pre></td></tr></table></figure></li><li><p>Yeoman安装(一个生成应用程序的工具)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yo</span><br></pre></td></tr></table></figure></li></ol><h4 id="（2）安装Playground"><a href="#（2）安装Playground" class="headerlink" title="（2）安装Playground:"></a>（2）安装Playground:</h4><ol><li><p>安装composer-playground：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g composer-playground@0.20</span><br></pre></td></tr></table></figure></li></ol><h4 id="（3）配置IDE开发环境"><a href="#（3）配置IDE开发环境" class="headerlink" title="（3）配置IDE开发环境:"></a>（3）配置IDE开发环境:</h4><p><strong>我们使用visual studio code去做开发的IDE：</strong></p><ol><li>从以下URL安装VSCode：<a href="https://code.visualstudio.com/download" target="_blank" rel="noopener">https</a>：//code.visualstudio.com/download</li><li>打开VSCode，转到Extensions，然后<code>Hyperledger Composer</code>从Marketplace中搜索并安装扩展程序。</li></ol><h4 id="（4）安装Hyperledger-Fabric："><a href="#（4）安装Hyperledger-Fabric：" class="headerlink" title="（4）安装Hyperledger Fabric："></a>（4）安装Hyperledger Fabric：</h4><p><strong>这个安装步骤提供部署业务网络的本地Hyperledger Fabric运行时</strong> ：</p><ol><li><p>选择一个目录，例如<code>~/fabric-dev-servers</code>，执行以下代码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/fabric-dev-servers &amp;&amp; <span class="built_in">cd</span> ~/fabric-dev-servers</span><br><span class="line">curl -O https://raw.githubusercontent.com/hyperledger/composer-tools/master/packages/fabric-dev-servers/fabric-dev-servers.tar.gz</span><br><span class="line">tar -xvf fabric-dev-servers.tar.gz进入进入刚刚下载的那个目录:</span><br></pre></td></tr></table></figure></li><li><p>进入刚刚下载的路径: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/fabric-dev-servers</span><br><span class="line"><span class="built_in">export</span> FABRIC_VERSION=hlfv12</span><br><span class="line">./downloadFabric.sh</span><br></pre></td></tr></table></figure></li></ol><h3 id="四、控制你的开发环境"><a href="#四、控制你的开发环境" class="headerlink" title="四、控制你的开发环境:"></a>四、控制你的开发环境:</h3><h4 id="（1）启动和停止Hyperledger-Fabric"><a href="#（1）启动和停止Hyperledger-Fabric" class="headerlink" title="（1）启动和停止Hyperledger Fabric"></a>（1）启动和停止Hyperledger Fabric</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/fabric-dev-servers</span><br><span class="line"><span class="built_in">export</span> FABRIC_VERSION=hlfv12</span><br><span class="line">./startFabric.sh</span><br><span class="line">./createPeerAdminCard.sh</span><br></pre></td></tr></table></figure><p>停止运行时：<code>~/fabric-dev-servers/stopFabric.sh</code></p><p>启动运行时：<code>~/fabric-dev-servers/startFabric.sh</code></p><p>（当运行了停止脚本，下次运行除了执行<code>startFabric.sh</code>，还需要运行<code>createPeerAdminCard.sh</code></p><h4 id="（2）启动网络应用程序（playground）"><a href="#（2）启动网络应用程序（playground）" class="headerlink" title="（2）启动网络应用程序（playground）"></a>（2）启动网络应用程序（playground）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer-playground</span><br></pre></td></tr></table></figure><p>然后使用浏览器访问 <a href="http://localhost:8080/login" target="_blank" rel="noopener">http://localhost:8080/login</a>  就可以打开<strong>playground</strong></p><h3 id="五、干净的销毁网络"><a href="#五、干净的销毁网络" class="headerlink" title="五、干净的销毁网络:"></a>五、干净的销毁网络:</h3><ol><li><p>执行<code>stopFabric.sh</code> 先关闭所有的容器:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/fabric-dev-servers</span><br><span class="line">./stopFabric.sh</span><br></pre></td></tr></table></figure></li><li><p>执行<code>docker container prune</code> 去消除所有的<strong>fabric</strong> 容器</p></li><li><p>执行<code>sudo rm ~/.composer/* -rf</code>清除<strong>composer</strong>网络残留的一些chaindata文件</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装Hyperledger-composer&quot;&gt;&lt;a href=&quot;#安装Hyperledger-composer&quot; class=&quot;headerlink&quot; title=&quot;安装Hyperledger composer&quot;&gt;&lt;/a&gt;安装Hyperledger compos
      
    
    </summary>
    
      <category term="区块链" scheme="https://blog.ywandy.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="https://blog.ywandy.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="hyperledger" scheme="https://blog.ywandy.top/tags/hyperledger/"/>
    
      <category term="composer" scheme="https://blog.ywandy.top/tags/composer/"/>
    
      <category term="nodejs" scheme="https://blog.ywandy.top/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>一步一步构建Hyperledger composer 开发环境 (一)</title>
    <link href="https://blog.ywandy.top/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%9E%84%E5%BB%BAHyperledger-composer-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E4%B8%80.html"/>
    <id>https://blog.ywandy.top/一步一步构建Hyperledger-composer-开发环境-一.html</id>
    <published>2018-08-15T06:17:51.000Z</published>
    <updated>2019-04-03T05:37:07.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Hyperledger-Composer"><a href="#什么是Hyperledger-Composer" class="headerlink" title="什么是Hyperledger Composer:"></a>什么是Hyperledger Composer:</h2><ul><li>Hyperledger Composer是一个广泛的开放式开发工具集和框架，可以更轻松地开发区块链应用程序。Hyperledger Composer的主要目标是加快实现价值的速度，并使区块链应用程序与现有业务系统的集成变得更加容易。我们可以使用Composer快速开发用例并在数周内而不是数月内部署区块链解决方案。</li><li>Hyperledger Composer允许您对业务网络进行建模，并将现有系统和数据与区块链应用程序集成。  </li><li>Hyperledger Composer支持现有的Hyperledger Fabric区块链基础架构和运行时  </li><li>Hyperledger Composer支持可插入的区块链共识协议，以确保指定的业务网络参与者根据策略验证事务。  </li><li>日常应用程序可以使用来自业务网络的数据，为最终用户提供简单且受控的访问点。  </li><li>您可以使用Hyperledger Composer快速建模您当前的业务网络，包含您现有的资产以及与之相关的交易; 资产是有形或无形的商品，服务或财产。作为业务网络模型的一部分，您可以定义可与资产交互的事务。业务网络还包括与多个业务网络交互的参与者，每个参与者可以与唯一身份相关联。  <h3 id="Hyperledger-Composer的示意图"><a href="#Hyperledger-Composer的示意图" class="headerlink" title="Hyperledger Composer的示意图:"></a>Hyperledger Composer的示意图:</h3><img src="http://storage.ywandy.top/BNA%20Overview-2018815.png" alt="BNA Overview-2018815"><h3 id="Hyperledger-Composer的基本概念"><a href="#Hyperledger-Composer的基本概念" class="headerlink" title="Hyperledger Composer的基本概念:"></a>Hyperledger Composer的基本概念:</h3></li><li><strong>区块链状态存储(Blockchain State Storage)</strong>:<br>  通过业务网络提交的所有事务都存储在区块链分类账中，资产和参与者的当前状态存储在区块链状态数据库中。区块链将分类帐和状态数据库分布在一组对等方中，并使用一致性算法确保对所有对等方的分类帐和状态数据库的更新是一致的。  </li><li><strong>连接配置文件(Connection Profiles)</strong>:<br>  Hyperledger Composer使用连接配置文件定义要连接的系统。连接配置文件是JSON文档，它是业务网卡的一部分。这些配置文件通常由它们引用的系统的创建者提供，并且应该用于创建业务网卡以便能够连接到该系统。  </li><li><strong>资产(Assets)</strong>:<br>  资产是有形或无形的商品，服务或财产，存储在注册管理机构中。资产几乎可以代表商业网络中的任何内容，例如，待售房屋，销售清单，该房屋的土地登记证书，以及该房屋的保险单据都可以是一个或多个商业网络中的资产,资产必须具有<strong>唯一标识符</strong>，但除此之外，它们可以包含您定义的任何属性。资产可能与其他资产或参与者有关.  </li><li><strong>参与者(Participants)</strong>:<br>  参与者是商业网络的成员。他们可能拥有资产并提交交易。参与者类型是建模的，与资产一样，必须具有标识符，并且可以根据需要具有任何其他属性。参与者可以映射到一个或多个身份。  </li><li><strong>身份(Identities)</strong>:<br>  身份是数字证书和私钥。身份用于在业务网络上进行交易，并且必须映射到业务网络中的参与者。单个身份存储在业务网卡中，如果该身份已映射到参与者，则允许该业务网卡的用户作为该参与者在业务网络上进行交易。  </li><li><strong>商务网卡(Business Network cards)</strong>:<br>  业务网卡是身份，连接配置文件和元数据的组合，元数据可选地包含要连接的业务网络的名称。业务网卡简化了连接到业务网络的过程，并将业务网络外的身份概念扩展到身份的“钱包”，每个身份与特定的业务网络和连接配置文件相关联。  </li><li><strong>交易(Transactions)</strong>:<br>  事务是参与者与资产交互的机制。这可以简单到参与者在拍卖中对资产进行投标，或者标记拍卖结束的拍卖者，自动将资产的所有权转移给最高出价者。</li><li><strong>查询(Queries)</strong>:<br>  查询用于返回有关区块链世界状态的数据。查询在业务网络中定义，并且可以包括用于简单定制的变量参数。通过使用查询，可以轻松地从区块链网络中提取数据。使用Hyperledger Composer API发送查询。  </li><li><strong>活动(Events)</strong>:<br>  事件在业务网络定义中以与资产或参与者相同的方式定义。一旦定义了事件，它们就可以由事务处理器函数发出，以向外部系统指示分类账发生了重要的事情。应用程序可以通过composer-clientAPI 订阅发出的事件。</li><li><strong>访问控制(Access Control)</strong>:<br>  业务网络可以包含一组访问控制规则。访问控制规则允许对参与者可以访问业务网络中的哪些资产以及在什么条件下进行细粒度控制。访问控制语言足够丰富，可以声明性地捕获复杂的条件，例如“只有车辆的所有者才能转让车辆的所有权”。从事务处理器功能逻辑外部化访问控制使得检查，调试，开发和维护变得更加容易。  </li><li><strong>历史记录(Historian registry)</strong>:<br>  历史记录是一个专门的注册表，记录成功的交易，包括提交它们的参与者和身份。历史记录将事务存储为HistorianRecord资产，这些资产在Hyperledger Composer系统命名空间中定义。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Hyperledger-Composer&quot;&gt;&lt;a href=&quot;#什么是Hyperledger-Composer&quot; class=&quot;headerlink&quot; title=&quot;什么是Hyperledger Composer:&quot;&gt;&lt;/a&gt;什么是Hyperledger C
      
    
    </summary>
    
      <category term="区块链" scheme="https://blog.ywandy.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="https://blog.ywandy.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="hyperledger" scheme="https://blog.ywandy.top/tags/hyperledger/"/>
    
      <category term="composer" scheme="https://blog.ywandy.top/tags/composer/"/>
    
      <category term="nodejs" scheme="https://blog.ywandy.top/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>区块链——双花问题</title>
    <link href="https://blog.ywandy.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E2%80%94%E2%80%94%E5%8F%8C%E8%8A%B1%E9%97%AE%E9%A2%98.html"/>
    <id>https://blog.ywandy.top/区块链——双花问题.html</id>
    <published>2018-08-12T14:56:52.000Z</published>
    <updated>2018-08-19T13:34:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是双花问题"><a href="#什么是双花问题" class="headerlink" title="什么是双花问题:"></a>什么是双花问题:</h2><p>我们常说，区块链在金融领域，主要是提供了一个解决“双花问题”的方法，我们首先来了解一下，什么是双花问题。<br>“双花”也叫做双重支付，在数字货币系统中，由于数据的可复制性，因此可能导致交易系统中存在同一笔数字资产被重复使用。<br>为什么“双花问题”在数字货币系统中会存在，而在显示的货币中不会存在，我们可以举两个例子：  </p><ul><li>假设小明拥有20元，他去咖啡店花费了20元购买了一杯咖啡，然后他此时身上是没钱的，然后他想去隔壁超市购买一件20元的商品，而他已经在咖啡店使用了这20元，那他有可能再去购买这20元的商品吗？由于他使用的是现金，显然是不可能的，当然他在买咖啡钱如果能完全复制那20元，就有可能    </li><li>现在假设小明使用的这20元不是现金，而是数字货币系统，例如他手持了一张20元的银行卡，假设他有能力复制了另一张银行卡，内容是完全一样的，然后，假设小明抓住了提交交易时候银行需要一定时间去处理，小明抓住了这个时间差，在短时间内使用这两张卡消费了，银行会同时收到同一个金额的两笔交易（当然我们要假设银行没有双花防范），这时候，小明使用同一笔钱成功的购买了两件不同的商品  </li></ul><p>以上的两种情况都是我们所说的双花，广义上，这两种情况都是双花，但是，具体来看，第一种情况是货币本身的问题，第二种情况是交易的问题。当然，实际上，要想在现金实现双花是在太难了，毕竟现金是事物，店员容易辨认现金金额，而数字货币只是数据，在数字交易系统，很容易因为数据的可复制性使得系统存在同一笔数字资产被重复使用的情况。我们可以知道，当一笔数字资产（也叫做token），一个序列号的字符串，被两次或者多次花掉，也就意味着能被更多次花掉，那么这个数字资产就没有任何价值的，因此数字资产更需要注重解决“双花问题”。  </p><h2 id="非区块链解决方法："><a href="#非区块链解决方法：" class="headerlink" title="非区块链解决方法："></a>非区块链解决方法：</h2><p>当今的银行和第三方中介机构（例如支付宝），都是从货币和交易两方面入手去解决的，以银行为例子，要是从货币的维度解决，假设小明自作聪明的去复制银行卡，他会发现，银行卡是无法复制的，卡的磁道、芯片信息是利用了信息安全加密的，因此无法复制银行卡；要是从交易的维度解决，假设小明实在太牛了，成功的复制了一张银行卡，然后他同时在两地同时消费了同样的金额，这样，在理想情况，银行能同时收到两笔交易请求，但是由于银行系统设定为原子性，因此银行自然会一笔一笔的去处理，理所当然，先处理哪一笔，小明都会标记为已经花费了那笔钱。  </p><h2 id="我们常用的支付宝-微信的解决方案："><a href="#我们常用的支付宝-微信的解决方案：" class="headerlink" title="我们常用的支付宝/微信的解决方案："></a>我们常用的支付宝/微信的解决方案：</h2><p>我们日常使用比较多的数字货币算是微信支付里面的钱也或者是支付宝里面的钱，事实上支付宝和微信里面的电子现金，并不是数字货币世界的钱（银行的电子现金是），但是却是存在于真实银行的，其实微信和支付宝并不是银行，而是交易的中介机构，当你走进咖啡店想要购买咖啡的时候，若你选择了支付宝或者微信支付，实际上发生了一下几个步骤:  </p><ol><li>把钱先给支付宝或者微信</li><li>支付宝或者微信把钱存在他们账户</li><li>当确认这笔交易后，支付宝或者微信会把钱从银行账户取出并且交给商家<br>当你要进行数字货币交易，首先你要把钱交给一个第三方机构，第三方机构去对钱和余额做中心化的管理，并修改用户的余额达到防范“双花”。  </li></ol><h2 id="常用中介解决方案的漏洞："><a href="#常用中介解决方案的漏洞：" class="headerlink" title="常用中介解决方案的漏洞："></a>常用中介解决方案的漏洞：</h2><p>由于进行“双花”防范是使用中心化的，也就是说，中心中介机构很明确，是微信/支付宝，要是如果这个中介机构被黑客攻陷（当然，这个工作量是非常大，也是非常不可能的）;也有一种可能，由于我们信任一个中心化的中介机构，当然，我们也许信任的不一定是微信/支付宝这种高信誉度的公司，也可能是其他的第三方机构，如果有人恶意篡改数据呢？这样将会使得整个数字货币世界都非常不安全。<br>按照上面的情况看来，我们要转移数字资产，是需要第三方的机构做中介，但是我们是否能够不通过中心化的第三方机构就向别人转移数字资产呢？</p><h2 id="迎刃而生的去中心化共识系统——区块链"><a href="#迎刃而生的去中心化共识系统——区块链" class="headerlink" title="迎刃而生的去中心化共识系统——区块链"></a>迎刃而生的去中心化共识系统——区块链</h2><p>要是从以上的两个维度，货币和交易本身来讲。从货币的维度来说，首先我们得知道，数字资产在区块链的账户只是一个序列化的hash地址，并且任何一个人都能看到，但是用户是加密的，每个用户都有自己的私钥和公钥（公钥能够通过私钥推出，并且能解码由私钥加密的数据，但是公钥不能反推私钥），因此这样保证了区块链的数字货币是安全的，并且是难以伪造的。其次，从交易的维度来说，区块链引入共识机制，我们常见的有pow，pos，这个也是区块链去中心化的核心思想，用奖励的方式让全网一起参与计算 ，在区块链的世界，要是用户之间要发生一笔交易，那么假设这双方是A和B，那么A要交易一个资产给B的话，需要这样做：</p><ol><li>把数字资产p用A的私钥签名并且广播到全网</li><li>这时候，提交的资产被称为UTXO，此时的交易是未经过验证的</li><li>全网通过A的公钥去验算是否这个数字资产属于A的</li><li>当通过后，全网的机器都把数字资产A的具体交易信息记录进入账本（区块链）  </li></ol><p>由以上的步骤，区块链中全网每一台机器都参与共识过程，全网通过公钥对交易进行所有权验证，区块链从密码学的角度解决了货币本身所有权的问题以及交易的唯一性问题。<br>在使用区块链后，如果小明存在双花问题，那么两笔交易会同时向全网广播，所有的区块链节点会收到广播的请求，同时每个节点上会存在全网所有的区块信息也就是全网的账户信息，来验证小明该交易的合法性。两笔交易一前一后到达那肯定没啥好说的，全网任意一个<strong>节点</strong>都能验证出第二笔为重复支付；若两笔交易同时达到两个节点中，两个节点同时验证为成功的同时广播到全网，若整个全网一部分阶段收到的第一笔交易，一部分节点收到的是第二笔交易都对本地数据进行了更新，那全网就出现了<strong>分叉</strong>（<em>区块链账本分叉问题</em>），好在区块链对交易的确认有两点：</p><ol><li>存在与最长分支中的block</li><li>至少有5个验证过的block再其后面得到验证</li></ol><p>所以出现<strong>分叉</strong>之后，全网的矿工会继续按照自己的区块更新，再之后的几次区块中自然会更新出最长的一条区块来，全网的所有矿工都以最长的区块信息为准。当然这样也不是绝对的，当小明控制了全网超过51%的算力，那么就能实现账本分叉，当然，要控制这么多算力的机器，小明显然也是得付出超过双花本身代价的努力</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是双花问题&quot;&gt;&lt;a href=&quot;#什么是双花问题&quot; class=&quot;headerlink&quot; title=&quot;什么是双花问题:&quot;&gt;&lt;/a&gt;什么是双花问题:&lt;/h2&gt;&lt;p&gt;我们常说，区块链在金融领域，主要是提供了一个解决“双花问题”的方法，我们首先来了解一下，什么是双
      
    
    </summary>
    
      <category term="区块链" scheme="https://blog.ywandy.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="https://blog.ywandy.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="密码学" scheme="https://blog.ywandy.top/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="金融" scheme="https://blog.ywandy.top/tags/%E9%87%91%E8%9E%8D/"/>
    
      <category term="双花问题" scheme="https://blog.ywandy.top/tags/%E5%8F%8C%E8%8A%B1%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>bitcoinj库的Hex类型私钥生成公钥java实现-sawtooth的keygen相关代码java实现</title>
    <link href="https://blog.ywandy.top/bitcoinj%E5%BA%93%E7%9A%84Hex%E7%B1%BB%E5%9E%8B%E7%A7%81%E9%92%A5%E7%94%9F%E6%88%90%E5%85%AC%E9%92%A5java%E5%AE%9E%E7%8E%B0-sawtooth%E7%9A%84keygen%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81java%E5%AE%9E%E7%8E%B0.html"/>
    <id>https://blog.ywandy.top/bitcoinj库的Hex类型私钥生成公钥java实现-sawtooth的keygen相关代码java实现.html</id>
    <published>2018-08-07T15:44:30.000Z</published>
    <updated>2018-08-19T13:33:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>我们在使用<em>hyperledger sawtooth</em>平台的时候，需要使用<em>keygen</em>这一个<strong>sawtooth</strong>的cli程序去创建一对密钥对，在<em>hyperledger sawtooth</em>中,该过程是使用一个特定的随机函数，生成一个私钥，再执行<em>Secp256k1</em>椭圆曲线算法，根据私钥导出公钥  </li><li><p>我在使用sawtooth的java sdk时候遇到了这样的问题，首先java的sdk 源码(<a href="https://github.com/hyperledger/sawtooth-sdk-java" target="_blank" rel="noopener">https://github.com/hyperledger/sawtooth-sdk-java</a>)  </p><ul><li><p>在sdk的example代码，调用了如下两个函数:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ECKey <span class="title">readWif</span><span class="params">(String wif)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DumpedPrivateKey.fromBase58(MAINNET, wif).getKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPublicKey</span><span class="params">(ECKey privateKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ECKey.fromPrivate(privateKey.getPrivKey(), <span class="keyword">true</span>).getPublicKeyAsHex();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>并且按照example给出的测试集其中一对公钥私钥如下:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">私钥: 5JkisHAXScTk6Tah9jq9S5B4ByiputRjnKnQrF6k1uBLBQAD8Mi </span><br><span class="line">公钥: 03bc976dc770b84decb90abeb94364c6368da051a9417cc4046f9f478d995b2ba7</span><br></pre></td></tr></table></figure><p>按照以上的调用，通过<code>readWif(String wif)</code> 把私钥导入，确实能够生成以上对应的公钥，也证明了bitcoinj库是没有任何问题  </p></li><li><p>同时我是用sawtooth自带的keygen工具去生成密钥对时候发现,sawtooth自带的生成公钥和私钥长度和以上测试用例的不一样，具体如下:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">私钥 ：&apos;20f34219eed055a8292767876e97cedc681cdee65f8d100f0c192d0b61cb13d6&apos; </span><br><span class="line">公钥 ：&apos;02fe868857f1dcb31137b34c55cf1b6e031447b5fe7902e49a083eaf95c54aaecf&apos;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>通过分析我们发现，example给出的例子使用的经过了base58编码的公私密钥对，而sawtooth原生的keygen则没有采用base58编码。因此如果使用java的bitcoinj库现有的方法能生成sawtooth keygen格式的公钥私钥对呢？这个就是本文的一个重点。  </p></li></ul><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h2><ol><li>我们首先观察example里面的Signing 类，发现里面调用的方法都是来自于ECKey这个类的，通过分析，首先在ECKey类里面的私钥都是使用BigInteger表示的，而我们sawtooth keygen生成的私钥是16位Hex格式的String  </li><li>因此我们需要使用方法把导入的String从16位Hex读入再变成BigInteger对象，再使用ECKey的fromPrivate((BigInteger privKey)方法，由BigInteger对象生成一个ECKey的对象。<br>具体的fromPrivate()方法如下:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ECKey <span class="title">fromPrivate</span><span class="params">(BigInteger privKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fromPrivate(privKey, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </li><li>最后通过getPublicKeyAsHex()方法即可得到由16位hex编码的String 公钥  </li></ol><h2 id="具体实现代码"><a href="#具体实现代码" class="headerlink" title="具体实现代码:"></a>具体实现代码:</h2><figure class="highlight java"><figcaption><span>getPublicKeyFromHex()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPublicKeyFromHex</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    BigInteger privateKeyBigInt = <span class="keyword">new</span> BigInteger(key,<span class="number">16</span>);</span><br><span class="line">    ECKey privateKey = ECKey.fromPrivate(privateKeyBigInt);</span><br><span class="line">    <span class="keyword">return</span> privateKey.getPublicKeyAsHex();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="实现的例子"><a href="#实现的例子" class="headerlink" title="实现的例子:"></a>实现的例子:</h2><figure class="highlight java"><figcaption><span>main.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.bitcoinj.core.ECKey;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPublicKeyFromHex</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        BigInteger privateKeyBigInt = <span class="keyword">new</span> BigInteger(key,<span class="number">16</span>);</span><br><span class="line">        ECKey privateKey = ECKey.fromPrivate(privateKeyBigInt);</span><br><span class="line">        <span class="keyword">return</span> privateKey.getPublicKeyAsHex();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此处我输入我上文提到的公钥</span></span><br><span class="line">        String privateKeyStr = <span class="string">"20f34219eed055a8292767876e97cedc681cdee65f8d100f0c192d0b61cb13d6"</span>;</span><br><span class="line">        System.out.println(getPublicKeyFromHex(privateKeyStr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <ul><li>程序执行结果:  <figure class="highlight plain"><figcaption><span>程序执行结果</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">02fe868857f1dcb31137b34c55cf1b6e031447b5fe7902e49a083eaf95c54aaecf</span><br></pre></td></tr></table></figure></li><li>我们成功的使用java实现了sawtooth自带的keygen功能，除了keygen的通过随机数生成privatekey外，我们已经实现了把keygen生成的私钥生成回sawtooth keygen兼容的公钥格式</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我们在使用&lt;em&gt;hyperledger sawtooth&lt;/em&gt;平台的时候，需要使用&lt;em&gt;keygen&lt;/em&gt;这一个&lt;s
      
    
    </summary>
    
      <category term="区块链" scheme="https://blog.ywandy.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="https://blog.ywandy.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="hyperledger" scheme="https://blog.ywandy.top/tags/hyperledger/"/>
    
      <category term="sawtooth" scheme="https://blog.ywandy.top/tags/sawtooth/"/>
    
      <category term="密码学" scheme="https://blog.ywandy.top/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="java" scheme="https://blog.ywandy.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>解决gnome3自己添加的程序dock栏图标重复问题</title>
    <link href="https://blog.ywandy.top/%E8%A7%A3%E5%86%B3gnome3%E8%87%AA%E5%B7%B1%E6%B7%BB%E5%8A%A0%E7%9A%84%E7%A8%8B%E5%BA%8Fdock%E6%A0%8F%E5%9B%BE%E6%A0%87%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98.html"/>
    <id>https://blog.ywandy.top/解决gnome3自己添加的程序dock栏图标重复问题.html</id>
    <published>2018-05-09T16:22:43.000Z</published>
    <updated>2019-04-03T05:36:31.754Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><p>最近我的主力笔记本<strong>Archlinux</strong>开始用<strong>Gnome3</strong>桌面，主要是<strong>Kde</strong>看腻了，Gnome3总体感觉还是非常好看的，这里先秀上一张我的<strong>Gnome3</strong>桌面，嘻嘻。<br><img src="http://storage.ywandy.top/2018-05-10%2000-28-19%20的屏幕截图.png" alt="2018-05-10 00-28-19 的屏幕截图"><br>但是<strong>Gnome3</strong>安装完后，我以前在<strong>Kde</strong>桌面的程序入口全部都没有了，包括我以前新建的一些程序快捷方式，因此只能按照<strong>freedesktop</strong>的标准去编写 <strong>.desktop</strong> 文件<br>然后编写的时候发现一个问题，就是我的 <strong>.desktop</strong> 文件虽然能够在<strong>Gnome</strong>的所有程序找到，也可以添加到收藏夹<img src="http://storage.ywandy.top/2018-05-10%2000-33-43%20的屏幕截图.png" alt="2018-05-10 00-33-43 的屏幕截图"><br>但是存在一个问题，就是会出现如下当应用程序启动后<strong>多个</strong>图标问题。<br><img src="http://storage.ywandy.top/2018-05-10%2000-36-22%20的屏幕截图.png" alt="2018-05-10 00-36-22 的屏幕截图"><br>这种问题对于追求完美的我来说，怎么能够忍受呢？因此，下面教程将会用一个简单的方法去处理这个问题。 </p><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>我们首先来对比一下，其他没有问题的应用程序的<strong>.desktop</strong>是怎么编写的，和我们有什么不同。 </p><ul><li><p><strong>以下是一个正常没有出现双图标的.desktop</strong>：<br><img src="http://storage.ywandy.top/2018-05-10%2000-38-31%20的屏幕截图.png" alt="2018-05-10 00-38-31 的屏幕截图"></p></li><li><p><strong>以下是我们出现双图标的eclipse的<code>.desktop</code></strong>:<br><img src="http://storage.ywandy.top/2018-05-10%2000-41-07%20的屏幕截图.png" alt="2018-05-10 00-41-07 的屏幕截图"> </p></li></ul><p>通过对比两图我们发现，正常的<strong>.desktop</strong>最下面有一行<code>StartupWMClass=</code>，这个也是我们今天的解决办法，下面，我们如何知道我们的<code>StartupWMClass=</code>需要填入什么呢，于是，我们需要接触一个新工具<code>xprop WM_CLASS</code><br>　　当我们在终端执行以下命令:</p><pre><code class="bash"><span class="comment"># yewei @ yewei in ~/yyw/code/ywandy.github.io on git:master x [0:45:13] </span>$ xprop WM_CLASS </code></pre><p>屏幕会出先一个像截图的 X ，然后这时候，我们用 X 去点击我们的eclipse窗口（对于其他应用一样，就去点击那个应用的窗口就好了）<br>　　此时的命令行会出现: </p><pre><code class="bash"><span class="comment"># yewei @ yewei in ~/yyw/code/ywandy.github.io on git:master x [0:47:18] C:130</span>$ xprop WM_CLASSWM_CLASS(STRING) = <span class="string">"Eclipse"</span>, <span class="string">"Eclipse"</span></code></pre><p>我们只需要把Eclipse填入我们的eclipse的<code>.desktop</code>最后一行即可，然后尝试启动eclipse<br>最终的<code>.desktop</code>是这样的：<br><img src="http://storage.ywandy.top/2018-05-10%2000-49-22%20的屏幕截图.png" alt="2018-05-10 00-49-22 的屏幕截图"> </p><p>此时，自建的<code>.desktop</code>导致dock栏的双图标问题已经解决了:<br><img src="http://storage.ywandy.top/2018-05-10%2000-50-29%20的屏幕截图.png" alt="2018-05-10 00-50-29 的屏幕截图"> </p><p>##附录:</p><ul><li>完整的<code>eclipse.desktop</code>文件： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Type=Application</span><br><span class="line">Name=Eclipse-cpp</span><br><span class="line">Comment=Eclipse Integrated Development Environment</span><br><span class="line">Icon=/home/yewei/yyw/application/eclipse-cpp/icon.xpm</span><br><span class="line">Exec=/home/yewei/yyw/application/eclipse-cpp/eclipse</span><br><span class="line">Terminal=false</span><br><span class="line">Categories=Development;IDE;Java;</span><br><span class="line">StartupWMClass=Eclipse</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景：&quot;&gt;&lt;a href=&quot;#背景：&quot; class=&quot;headerlink&quot; title=&quot;背景：&quot;&gt;&lt;/a&gt;背景：&lt;/h3&gt;&lt;p&gt;最近我的主力笔记本&lt;strong&gt;Archlinux&lt;/strong&gt;开始用&lt;strong&gt;Gnome3&lt;/strong&gt;桌面，主要
      
    
    </summary>
    
      <category term="技巧总结" scheme="https://blog.ywandy.top/categories/%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Gnome" scheme="https://blog.ywandy.top/tags/Gnome/"/>
    
      <category term="freedesktop" scheme="https://blog.ywandy.top/tags/freedesktop/"/>
    
  </entry>
  
  <entry>
    <title>Nginx通过反向代理的方法去访问Gitlab</title>
    <link href="https://blog.ywandy.top/Nginx%E9%80%9A%E8%BF%87%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95%E5%8E%BB%E8%AE%BF%E9%97%AEGitlab.html"/>
    <id>https://blog.ywandy.top/Nginx通过反向代理的方法去访问Gitlab.html</id>
    <published>2018-04-28T01:59:56.000Z</published>
    <updated>2018-08-09T01:03:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景:"></a>背景:</h3><p>最近用为企业部署了<strong>Gitlab</strong>用来存放代码用。<br><strong>Gitlab</strong>是一个企业能够很方便的管理代码的工具，官方提供的安装配置也很方便的部署<strong>Gitlab</strong> 到企业的服务器<br><strong>Gitlab</strong>本身自带了<strong>Nginx</strong>，并且如果不改动任何配置的话，<strong>Gitlab</strong>默认会部署到<strong>80</strong>端口。<br>由于企业在这个服务器有很多其他的web服务，要做到<strong>Gitlab</strong>和其他的web服务共存，那么需要做一点点修改</p><h3 id="方案"><a href="#方案" class="headerlink" title="方案:"></a>方案:</h3><ul><li>方法一：干掉<strong>Gitlab</strong>的内置<strong>Nginx</strong>，然后在外部安装nginx服务器，并且代理了<strong>Nginx</strong>的socket端口。  </li><li>方法二：在外部的<strong>Nginx</strong>服务器做代理转发，这个方法不需要禁用<strong>Gitlab</strong>本身的<strong>Nginx</strong>服务，只需要在外部的<strong>Nginx</strong>做相关的改动即可。<br>（由于不想改动太多，以及涉及到集成化的原因，就不打算动<strong>Gitlab</strong>内部的<strong>Nginx</strong>，方案二也就是本文介绍的方法，就是用我们外部的<strong>Nginx</strong>去代理转发请求到<strong>Gitlab</strong>的服务端口)  </li></ul><h3 id="实现-方案二"><a href="#实现-方案二" class="headerlink" title="实现(方案二):"></a>实现(方案二):</h3><ol><li>修改<strong>Gitlab</strong>的配置文件： <ul><li>默认安装的<strong>Gitlab</strong>，配置文件在 :<code>/etc/gitlab/gitlab.rb</code>  </li><li>修改<strong>Gitlab</strong>的监听端口号:<br><code>nginx[&#39;listen_port&#39;] = 端口号</code>    </li><li>修改<strong>Gitlab</strong>的域名：<br><code>external_url &#39;域名&#39;</code><br>（注意，此处的域名不需要带上端口号，因为请求是被我们前级的Nginx处理的，然后把请求转发过来这个端口，对外访问而言，还是我们的前级Nginx的80端口)  </li><li>最后执行  <code>gitlab-ctrl reconfigure</code> 让配置生效  </li></ul></li><li>配置<strong>Nginx</strong>服务器的站点配置文件 <code>default.conf</code>：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">upstream  git&#123;</span><br><span class="line">    # 域名对应 gitlab配置中的 external_url</span><br><span class="line">    # 端口对应 gitlab 配置中的 nginx[&apos;listen_port&apos;]</span><br><span class="line">    server  域名:端口;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    # 此域名是提供给最终用户的访问地址</span><br><span class="line">    server_name 域名;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        # 这个大小的设置非常重要，如果 git 版本库里面有大文件，设置的太小，文件push 会失败，根据情况调整</span><br><span class="line">        client_max_body_size 50m;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        #以下确保 gitlab中项目的 url 是域名而不是 http://git，不可缺少</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        # 反向代理到 gitlab 内置的 nginx</span><br><span class="line">        proxy_pass http://git;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景:&quot;&gt;&lt;/a&gt;背景:&lt;/h3&gt;&lt;p&gt;最近用为企业部署了&lt;strong&gt;Gitlab&lt;/strong&gt;用来存放代码用。&lt;br&gt;&lt;strong&gt;Gitlab&lt;/strong&gt;是
      
    
    </summary>
    
      <category term="技巧总结" scheme="https://blog.ywandy.top/categories/%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Gitlab" scheme="https://blog.ywandy.top/tags/Gitlab/"/>
    
      <category term="nginx" scheme="https://blog.ywandy.top/tags/nginx/"/>
    
      <category term="服务器" scheme="https://blog.ywandy.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
</feed>
